#version 330

layout(std140) uniform meshWideBlockPS
{
    int drawDepth;
    float uFarPlane;
    float uNearPlane;
} _10;

uniform sampler2D diffuse;

in vec2 texCoord;
layout(location = 0) out vec4 fragColor;

void main()
{
    vec4 finalColor;
    if (_10.drawDepth == 1)
    {
        float f = _10.uFarPlane;
        float n = _10.uNearPlane;
        float z = (2.0 * n) / ((f + n) - (texture(diffuse, texCoord).x * (f - n)));
        finalColor = vec4(z, z, z, 255.0);
    }
    else
    {
        finalColor = vec4(texture(diffuse, texCoord).xyz, 255.0);
    }
    fragColor = finalColor;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    vec4 uAlphaTestv;
    ivec4 uPixelShaderv;
} _38;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

in vec2 vTexcoord0;
in vec2 vTexcoord1;
in vec2 vTexcoord2;
in vec4 vColor;
layout(location = 0) out vec4 outputColor;

void main()
{
    vec4 tex = texture(uTexture, vTexcoord0);
    vec4 tex2 = texture(uTexture2, vTexcoord1);
    vec4 tex3 = texture(uTexture3, vTexcoord2);
    float uAlphaTest = _38.uAlphaTestv.x;
    if (tex.w < uAlphaTest)
    {
        discard;
    }
    vec4 finalColor = vec4((tex * vColor).xyz, tex.w * vColor.w);
    int uNonOptPixelShader = _38.uPixelShaderv.x;
    if (uNonOptPixelShader == 0)
    {
        vec3 matDiffuse = vColor.xyz * tex.xyz;
        finalColor = vec4(matDiffuse, tex.w * vColor.w);
    }
    else
    {
        if (uNonOptPixelShader == 1)
        {
            vec4 textureMod = tex * tex2;
            float texAlpha = textureMod.w * tex3.w;
            float opacity = texAlpha * vColor.w;
            vec3 matDiffuse_1 = vColor.xyz * textureMod.xyz;
            finalColor = vec4(matDiffuse_1, opacity);
        }
        else
        {
            if (uNonOptPixelShader == 2)
            {
                vec4 textureMod_1 = (tex * tex2) * tex3;
                float texAlpha_1 = textureMod_1.w;
                float opacity_1 = texAlpha_1 * vColor.w;
                vec3 matDiffuse_2 = vColor.xyz * textureMod_1.xyz;
                finalColor = vec4(matDiffuse_2, opacity_1);
            }
            else
            {
                if (uNonOptPixelShader == 3)
                {
                    vec4 textureMod_2 = (tex * tex2) * tex3;
                    float texAlpha_2 = textureMod_2.w;
                    float opacity_2 = texAlpha_2 * vColor.w;
                    vec3 matDiffuse_3 = vColor.xyz * textureMod_2.xyz;
                    finalColor = vec4(matDiffuse_3, opacity_2);
                }
                else
                {
                    if (uNonOptPixelShader == 4)
                    {
                    }
                }
            }
        }
    }
    if (finalColor.w < uAlphaTest)
    {
        discard;
    }
    outputColor = finalColor;
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _30;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _40;

layout(location = 0) in vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4(aPosition, 1.0);
    gl_Position = ((_30.uPMatrix * _30.uLookAtMat) * _40.uPlacementMat) * worldPoint;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct LocalLight
{
    vec4 color;
    vec4 position;
    vec4 attenuation;
};

layout(std140) uniform meshWideBlockPS
{
    ivec4 PixelShader_UnFogged_IsAffectedByLight;
    vec4 uFogColorAndAlphaTest;
    vec4 uPcColor;
} _246;

layout(std140) uniform modelWideBlockPS
{
    InteriorLightParam intLight;
    LocalLight pc_lights[4];
    ivec4 lightCount;
    vec4 interiorExteriorBlend;
} _271;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
} _310;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
} _318;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;
uniform sampler2D uTexture4;

in vec2 vTexCoord;
in vec2 vTexCoord2;
in vec2 vTexCoord3;
in vec4 vDiffuseColor;
in vec3 vPosition;
in vec3 vNormal;
layout(location = 0) out vec4 outputColor;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight)
{
    vec3 localDiffuse = accumLight;
    if (!applyLight)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    vec3 currColor;
    if (intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        if (nDotUp >= 0.0)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    if (intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        if (intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = vec3(0.0);
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

void main()
{
    vec2 texCoord = vTexCoord;
    vec2 texCoord2 = vTexCoord2;
    vec2 texCoord3 = vTexCoord3;
    vec4 tex = texture(uTexture, texCoord);
    vec4 tex2 = texture(uTexture2, texCoord2);
    vec4 tex3 = texture(uTexture3, texCoord3);
    vec4 tex2WithTextCoord1 = texture(uTexture2, texCoord);
    vec4 tex3WithTextCoord1 = texture(uTexture3, texCoord);
    vec4 tex4WithTextCoord2 = texture(uTexture4, texCoord2);
    vec4 finalColor = vec4(0.0);
    vec4 meshResColor = vDiffuseColor;
    vec3 accumLight;
    if (_246.PixelShader_UnFogged_IsAffectedByLight.z == 1)
    {
        vec3 vPos3 = vPosition;
        vec3 vNormal3 = normalize(vNormal);
        vec3 lightColor = vec3(0.0);
        int count = int(_271.pc_lights[0].attenuation.w);
        LocalLight lightRecord;
        for (int index = 0; index < 4; index++)
        {
            if (index >= _271.lightCount.x)
            {
                break;
            }
            lightRecord.color = _271.pc_lights[index].color;
            lightRecord.position = _271.pc_lights[index].position;
            lightRecord.attenuation = _271.pc_lights[index].attenuation;
            vec3 vectorToLight = (_310.scene.uLookAtMat * (_318.uPlacementMat * lightRecord.position)).xyz - vPos3;
            float distanceToLightSqr = dot(vectorToLight, vectorToLight);
            float distanceToLightInv = inversesqrt(distanceToLightSqr);
            float distanceToLight = distanceToLightSqr * distanceToLightInv;
            float diffuseTerm1 = max(dot(vectorToLight, vNormal3) * distanceToLightInv, 0.0);
            vec4 attenuationRec = lightRecord.attenuation;
            float attenuation = 1.0 - clamp((distanceToLight - attenuationRec.x) * (1.0 / (attenuationRec.z - attenuationRec.x)), 0.0, 1.0);
            vec3 attenuatedColor = (lightRecord.color.xyz * attenuation) * attenuationRec.y;
            lightColor += vec3((attenuatedColor * attenuatedColor) * diffuseTerm1);
        }
        vec3 _389 = clamp(lightColor, vec3(0.0), vec3(1.0));
        meshResColor = vec4(_389.x, _389.y, _389.z, meshResColor.w);
        accumLight = meshResColor.xyz;
    }
    float finalOpacity = 0.0;
    vec3 specular = vec3(0.0);
    vec3 visParams = vec3(1.0);
    vec4 genericParams[3];
    genericParams[0] = vec4(1.0);
    genericParams[1] = vec4(1.0);
    genericParams[2] = vec4(1.0);
    int uPixelShader = _246.PixelShader_UnFogged_IsAffectedByLight.x;
    vec3 matDiffuse;
    float opacity;
    #if (FRAGMENTSHADER == 0)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 1)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 2)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = tex2.w * vDiffuseColor.w;
    opacity = tex2.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 3)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = (tex2.w * 2.0) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 4)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 5)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 6)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = (tex.w * tex2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 7)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = ((tex.w * tex2.w) * 2.0) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 8)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + tex2.w) * vDiffuseColor.w;
    specular = tex2.xyz;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 9)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 10)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = tex2.xyz;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 11)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 12)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 13)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = tex2.xyz * tex2.w;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 14)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 15)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    specular = (tex3.xyz * tex3.w) * genericParams[0].z;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 16)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = tex2.xyz * tex2.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 17)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + (tex2.w * (((0.300000011920928955078125 * tex2.x) + (0.589999973773956298828125 * tex2.y)) + (0.10999999940395355224609375 * tex2.z)))) * vDiffuseColor.w;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 18)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex.xyz, tex2.xyz, vec3(tex2.w)), tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 19)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 20)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * genericParams[0].y;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 21)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + tex2.w) * vDiffuseColor.w;
    specular = tex2.xyz * (1.0 - tex.w);
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 22)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * tex2.xyz, tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 23)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = (tex2.xyz * tex2.w) * genericParams[0].y;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 24)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    specular = (tex.xyz * tex.w) * genericParams[0].x;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 25)
    float glowOpacity = clamp(tex3.w * genericParams[0].z, 0.0, 1.0);
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w))) * (1.0 - glowOpacity);
    specular = tex3.xyz * glowOpacity;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 26)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).xyz;
    opacity = mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 27)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w)), tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 28)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).xyz;
    opacity = (mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).w * tex4WithTextCoord2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 29)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 30)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 31)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w));
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 32)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 33)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w * vDiffuseColor.w) * visParams.x;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 34)
    finalColor = vec4(1.0);
    #endif
    #if (FRAGMENTSHADER == 35)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * (((tex * tex2) * tex3) * genericParams[0]).xyz;
    opacity = (((tex * tex2) * tex3) * genericParams[0]).w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = _246.PixelShader_UnFogged_IsAffectedByLight.z > 0;
    float param_3 = _271.interiorExteriorBlend.x;
    SceneWideParams param_4;
    param_4.uLookAtMat = _310.scene.uLookAtMat;
    param_4.uPMatrix = _310.scene.uPMatrix;
    param_4.uViewUp = _310.scene.uViewUp;
    param_4.uInteriorSunDir = _310.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _310.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _310.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _310.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _310.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _310.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5;
    param_5.uInteriorAmbientColorAndApplyInteriorLight = _271.intLight.uInteriorAmbientColorAndApplyInteriorLight;
    param_5.uInteriorDirectColorAndApplyExteriorLight = _271.intLight.uInteriorDirectColorAndApplyExteriorLight;
    vec3 param_6 = accumLight;
    finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vec3(0.0)), finalOpacity);
    if (finalColor.w < _246.uFogColorAndAlphaTest.w)
    {
        discard;
    }
    outputColor = finalColor;
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    vec3 uColor;
} _13;

layout(location = 0) out vec4 fragColor;
in vec4 vPos;

void main()
{
    fragColor = vec4(_13.uColor, 1.0);
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    vec4 color;
} _12;

uniform sampler2D uTexture;

layout(location = 0) out vec4 outputColor;
in vec2 vTextCoords;
in vec3 vPosition;

void main()
{
    outputColor = vec4(_12.color.xyz * texture(uTexture, vTextCoords).xyz, 0.699999988079071044921875);
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    vec4 uBBScale;
    vec4 uBBCenter;
    vec4 uColor;
} _13;

layout(location = 0) out vec4 outColor;

void main()
{
    vec4 finalColor = _13.uColor;
    outColor = finalColor;
}


#version 330

layout(std140) uniform modelWideBlockPS
{
    vec3 uColor;
} _19;

layout(location = 0) out vec4 fragColor;

void main()
{
    vec4 finalColor = vec4(1.0, 1.0, 0.0, 1.0);
    fragColor = finalColor;
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    vec4 uColor;
} _12;

layout(location = 0) out vec4 fragColor;

void main()
{
    vec4 finalColor = _12.uColor;
    fragColor = finalColor;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
} _43;

layout(location = 0) in vec3 aPosition;
out vec4 vColor;
layout(location = 1) in vec4 aColor;
out vec2 vTexcoord0;
layout(location = 2) in vec2 aTexcoord0;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    gl_Position = (_43.scene.uPMatrix * _43.scene.uLookAtMat) * aPositionVec4;
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _13;

layout(location = 0) in vec3 aPosition;

void main()
{
    vec4 c_world = inverse(_13.uPMatrix) * vec4(aPosition, 1.0);
    c_world = (c_world * 1.0) / vec4(c_world.w);
    gl_Position = (_13.uPMatrix * _13.uLookAtMat) * vec4(c_world.xyz, 1.0);
}


#version 330
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

layout(location = 0) in vec4 a_position;
out vec2 v_texcoord;

void main()
{
    gl_Position = a_position;
    v_texcoord = (a_position.xy * 0.5) + vec2(0.5);
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _19;

layout(location = 0) in vec2 aPosition;

void main()
{
    gl_Position = (_19.uPMatrix * _19.uLookAtMat) * vec4(aPosition, 0.0, 1.0);
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    vec4 uBBScale;
    vec4 uBBCenter;
    vec4 uColor;
} _21;

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _59;

layout(location = 0) in vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4((aPosition.x * _21.uBBScale.x) + _21.uBBCenter.x, (aPosition.y * _21.uBBScale.y) + _21.uBBCenter.y, (aPosition.z * _21.uBBScale.z) + _21.uBBCenter.z, 1.0);
    gl_Position = ((_59.uPMatrix * _59.uLookAtMat) * _21.uPlacementMat) * worldPoint;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    ivec4 waterTypeV;
} _12;

uniform sampler2D uTexture;

layout(location = 0) out vec4 outputColor;
in vec3 vPosition;

void main()
{
    int waterType = _12.waterTypeV.x;
    if (waterType == 13)
    {
        outputColor = vec4(0.0, 0.0, 0.300000011920928955078125, 0.5);
    }
    else
    {
        if (waterType == 14)
        {
            outputColor = vec4(0.0, 0.0, 0.800000011920928955078125, 0.800000011920928955078125);
        }
        else
        {
            if (waterType == 19)
            {
                outputColor = vec4(0.300000011920928955078125, 0.0, 0.0, 0.5);
            }
            else
            {
                if (waterType == 20)
                {
                    outputColor = vec4(0.0, 0.5, 0.0, 0.5);
                }
                else
                {
                    outputColor = vec4(0.5);
                }
            }
        }
    }
}


#version 330

layout(std140) uniform modelWideBlockPS
{
    vec4 uViewUp;
    vec4 uSunDir_FogStart;
    vec4 uSunColor_uFogEnd;
    vec4 uAmbientLight;
    vec4 FogColor;
    int uNewFormula;
} _65;

uniform sampler2D uDiffuseTexture;
uniform sampler2D uNormalTexture;

in vec2 vChunkCoords;
in vec3 vPosition;
layout(location = 0) out vec4 fragColor;

void main()
{
    vec2 TextureCoords = vec2(vChunkCoords.x, vChunkCoords.y);
    vec4 texDiffuse = texture(uDiffuseTexture, TextureCoords);
    vec3 matDiffuse = texDiffuse.xyz;
    vec3 vNormal = (texture(uNormalTexture, TextureCoords).xyz * 2.0) - vec3(1.0);
    vNormal = vec3(-vNormal.z, -vNormal.x, vNormal.y);
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 fogColor = _65.FogColor.xyz;
    float fog_start = _65.uSunDir_FogStart.w;
    float fog_end = _65.uSunColor_uFogEnd.w;
    float fog_rate = 1.5;
    float fog_bias = 0.00999999977648258209228515625;
    float distanceToCamera = length(vPosition);
    float z_depth = distanceToCamera - fog_bias;
    float expFog = 1.0 / exp(max(0.0, z_depth - fog_start) * fog_rate);
    float heightFog = 1.0;
    expFog += heightFog;
    float endFadeFog = clamp((fog_end - distanceToCamera) / (0.699999988079071044921875 * fog_end), 0.0, 1.0);
    vec3 _123 = mix(fogColor, finalColor.xyz, vec3(min(expFog, endFadeFog)));
    finalColor = vec4(_123.x, _123.y, _123.z, finalColor.w);
    finalColor.w = 1.0;
    fragColor = finalColor;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    float gauss_offsets[5];
    float gauss_weights[5];
    vec2 uResolution;
} _34;

uniform sampler2D u_sampler;
uniform sampler2D u_depth;

in vec2 v_texcoord;
layout(location = 0) out vec4 outputColor;

void main()
{
    float FXAA_SPAN_MAX = 8.0;
    float FXAA_REDUCE_MUL = 0.125;
    float FXAA_REDUCE_MIN = 0.0078125;
    vec3 rgbNW = texture(u_sampler, v_texcoord + (vec2(-1.0) / _34.uResolution)).xyz;
    vec3 rgbNE = texture(u_sampler, v_texcoord + (vec2(1.0, -1.0) / _34.uResolution)).xyz;
    vec3 rgbSW = texture(u_sampler, v_texcoord + (vec2(-1.0, 1.0) / _34.uResolution)).xyz;
    vec3 rgbSE = texture(u_sampler, v_texcoord + (vec2(1.0) / _34.uResolution)).xyz;
    vec3 rgbM = texture(u_sampler, v_texcoord).xyz;
    vec3 luma = vec3(0.2989999949932098388671875, 0.58700001239776611328125, 0.114000000059604644775390625);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM = dot(rgbM, luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y = (lumaNW + lumaSW) - (lumaNE + lumaSE);
    float dirReduce = max((((lumaNW + lumaNE) + lumaSW) + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) / _34.uResolution;
    vec3 rgbA = (texture(u_sampler, v_texcoord + (dir * (-0.16666667163372039794921875))).xyz + texture(u_sampler, v_texcoord + (dir * 0.16666667163372039794921875)).xyz) * 0.5;
    vec3 rgbB = (rgbA * 0.5) + ((texture(u_sampler, v_texcoord + (dir * (-0.5))).xyz + texture(u_sampler, v_texcoord + (dir * 0.5)).xyz) * 0.25);
    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
    {
        outputColor = vec4(rgbA.x, rgbA.y, rgbA.z, outputColor.w);
    }
    else
    {
        outputColor = vec4(rgbB.x, rgbB.y, rgbB.z, outputColor.w);
    }
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
} _90;

layout(std140) uniform meshWideBlockVS
{
    vec4 uPos;
} _130;

layout(location = 4) in float aIndex;
layout(location = 0) in vec3 aHeight;
out vec2 vChunkCoords;
out vec3 vPosition;
out vec4 vColor;
layout(location = 1) in vec4 aColor;
out vec3 vVertexLighting;
layout(location = 2) in vec4 aVertexLighting;
out vec3 vNormal;
layout(location = 3) in vec3 aNormal;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

void main()
{
    float iX = mod(aIndex, 17.0);
    float iY = floor(aIndex / 17.0);
    if (iX > 8.0100002288818359375)
    {
        iY += 0.5;
        iX -= 8.5;
    }
    vec4 worldPoint = vec4(aHeight, 1.0);
    vChunkCoords = vec2(iX, iY);
    vPosition = (_90.scene.uLookAtMat * worldPoint).xyz;
    vColor = aColor;
    vVertexLighting = aVertexLighting.xyz;
    mat4 param = _90.scene.uLookAtMat;
    vNormal = blizzTranspose(param) * aNormal;
    gl_Position = (_90.scene.uPMatrix * _90.scene.uLookAtMat) * worldPoint;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

layout(std140) uniform meshWideBlockPS
{
    vec4 uHeightScale;
    vec4 uHeightOffset;
} _251;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
} _427;

layout(std140) uniform modelWideBlockPS
{
    vec4 uFogStartAndFogEnd;
    vec4 uFogColor;
} _514;

uniform sampler2D uAlphaTexture;
uniform sampler2D uLayerHeight0;
uniform sampler2D uLayerHeight1;
uniform sampler2D uLayerHeight2;
uniform sampler2D uLayerHeight3;
uniform sampler2D uLayer0;
uniform sampler2D uLayer1;
uniform sampler2D uLayer2;
uniform sampler2D uLayer3;

in vec2 vChunkCoords;
in vec4 vColor;
in vec3 vNormal;
in vec3 vVertexLighting;
in vec3 vPosition;
layout(location = 0) out vec4 outColor;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight)
{
    vec3 localDiffuse = accumLight;
    if (!applyLight)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    vec3 currColor;
    if (intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        if (nDotUp >= 0.0)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    if (intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        if (intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = vec3(0.0);
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

void main()
{
    vec2 vTexCoord = vChunkCoords;
    vec2 alphaCoord = vec2(vChunkCoords.x / 8.0, vChunkCoords.y / 8.0);
    vec3 alphaBlend = texture(uAlphaTexture, alphaCoord).yzw;
    vec2 tcLayer0 = vTexCoord;
    vec2 tcLayer1 = vTexCoord;
    vec2 tcLayer2 = vTexCoord;
    vec2 tcLayer3 = vTexCoord;
    float minusAlphaBlendSum = 1.0 - clamp(dot(alphaBlend, vec3(1.0)), 0.0, 1.0);
    vec4 weightsVector = vec4(minusAlphaBlendSum, alphaBlend);
    float weightedTexture_x = minusAlphaBlendSum * ((texture(uLayerHeight0, tcLayer0).w * _251.uHeightScale.x) + _251.uHeightOffset.x);
    float weightedTexture_y = weightsVector.y * ((texture(uLayerHeight1, tcLayer1).w * _251.uHeightScale.y) + _251.uHeightOffset.y);
    float weightedTexture_z = weightsVector.z * ((texture(uLayerHeight2, tcLayer2).w * _251.uHeightScale.z) + _251.uHeightOffset.z);
    float weightedTexture_w = weightsVector.w * ((texture(uLayerHeight3, tcLayer3).w * _251.uHeightScale.w) + _251.uHeightOffset.w);
    vec4 weights = vec4(weightedTexture_x, weightedTexture_y, weightedTexture_z, weightedTexture_w);
    vec4 weights_temp = weights * (vec4(1.0) - clamp(vec4(max(max(weightedTexture_x, weightedTexture_y), max(weightedTexture_z, weightedTexture_w))) - weights, vec4(0.0), vec4(1.0)));
    vec4 weightsNormalized = weights_temp / vec4(dot(vec4(1.0), weights_temp));
    vec4 weightedLayer_0 = texture(uLayer0, tcLayer0) * weightsNormalized.x;
    vec3 matDiffuse_0 = weightedLayer_0.xyz;
    float specBlend_0 = weightedLayer_0.w;
    vec4 weightedLayer_1 = texture(uLayer1, tcLayer1) * weightsNormalized.y;
    vec3 matDiffuse_1 = matDiffuse_0 + weightedLayer_1.xyz;
    float specBlend_1 = specBlend_0 + weightedLayer_1.w;
    vec4 weightedLayer_2 = texture(uLayer2, tcLayer1) * weightsNormalized.z;
    vec3 matDiffuse_2 = matDiffuse_1 + weightedLayer_2.xyz;
    float specBlend_2 = specBlend_1 + weightedLayer_2.w;
    vec4 weightedLayer_3 = texture(uLayer3, tcLayer1) * weightsNormalized.w;
    vec3 matDiffuse_3 = matDiffuse_2 + weightedLayer_3.xyz;
    float specBlend_3 = specBlend_2 + weightedLayer_3.w;
    vec4 final = vec4(matDiffuse_3, specBlend_3);
    vec3 matDiffuse = final.xyz * vColor.xyz;
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = true;
    float param_3 = 0.0;
    SceneWideParams param_4;
    param_4.uLookAtMat = _427.scene.uLookAtMat;
    param_4.uPMatrix = _427.scene.uPMatrix;
    param_4.uViewUp = _427.scene.uViewUp;
    param_4.uInteriorSunDir = _427.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _427.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _427.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _427.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _427.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _427.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5 = InteriorLightParam(vec4(0.0), vec4(0.0, 0.0, 0.0, 1.0));
    vec3 param_6 = vVertexLighting;
    vec4 finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vec3(0.0)), 1.0);
    float specBlend = final.w;
    vec3 halfVec = -normalize(_427.scene.extLight.uExteriorDirectColorDir.xyz + normalize(vPosition));
    vec3 lSpecular = _427.scene.extLight.uExteriorDirectColor.xyz * pow(max(0.0, dot(halfVec, vNormal)), 20.0);
    vec3 specTerm = vec3(specBlend) * lSpecular;
    vec3 _505 = finalColor.xyz + specTerm;
    finalColor = vec4(_505.x, _505.y, _505.z, finalColor.w);
    finalColor.w = 1.0;
    outColor = finalColor;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    vec3 uColor;
} _22;

layout(location = 0) out vec4 fragColor;

void main()
{
    vec4 finalColor = vec4(1.0);
    finalColor.w = 1.0;
    fragColor = finalColor;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
} _133;

layout(std140) uniform meshWideBlockVS
{
    ivec4 vertexShader_IsAffectedByLight;
    vec4 color_Transparency;
    mat4 uTextMat[2];
} _230;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
} _239;

layout(location = 0) in vec3 aPosition;
layout(location = 3) in vec4 boneWeights;
layout(location = 2) in vec4 bones;
layout(location = 1) in vec3 aNormal;
out vec2 vTexCoord2;
out vec2 vTexCoord3;
out vec4 vDiffuseColor;
out vec2 vTexCoord;
layout(location = 4) in vec2 aTexCoord;
layout(location = 5) in vec2 aTexCoord2;
out vec3 vNormal;
out vec3 vPosition;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(inout vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

float edgeScan(inout vec3 position, vec3 normal)
{
    float dotProductClamped = clamp(dot(-normalize(position), normal), 0.0, 1.0);
    return clamp(((2.7000000476837158203125 * dotProductClamped) * dotProductClamped) - 0.4000000059604644775390625, 0.0, 1.0);
}

void main()
{
    vec4 modelPoint = vec4(0.0);
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    mat4 boneTransformMat = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0));
    mat4 _143 = _133.uBoneMatrixes[bones.x] * boneWeights.x;
    boneTransformMat = mat4(boneTransformMat[0] + _143[0], boneTransformMat[1] + _143[1], boneTransformMat[2] + _143[2], boneTransformMat[3] + _143[3]);
    mat4 _164 = _133.uBoneMatrixes[bones.y] * boneWeights.y;
    boneTransformMat = mat4(boneTransformMat[0] + _164[0], boneTransformMat[1] + _164[1], boneTransformMat[2] + _164[2], boneTransformMat[3] + _164[3]);
    mat4 _185 = _133.uBoneMatrixes[bones.z] * boneWeights.z;
    boneTransformMat = mat4(boneTransformMat[0] + _185[0], boneTransformMat[1] + _185[1], boneTransformMat[2] + _185[2], boneTransformMat[3] + _185[3]);
    mat4 _207 = _133.uBoneMatrixes[bones.w] * boneWeights.w;
    boneTransformMat = mat4(boneTransformMat[0] + _207[0], boneTransformMat[1] + _207[1], boneTransformMat[2] + _207[2], boneTransformMat[3] + _207[3]);
    mat4 placementMat = _133.uPlacementMat;
    vec4 lDiffuseColor = _230.color_Transparency;
    mat4 cameraMatrix = (_239.scene.uLookAtMat * placementMat) * boneTransformMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    mat4 param = _239.scene.uLookAtMat;
    mat4 param_1 = placementMat;
    mat4 param_2 = boneTransformMat;
    mat3 viewModelMatTransposed = (blizzTranspose(param) * blizzTranspose(param_1)) * blizzTranspose(param_2);
    vec3 normal = normalize(viewModelMatTransposed * aNormal);
    vec4 combinedColor = clamp(lDiffuseColor, vec4(0.0), vec4(1.0));
    vec4 combinedColorHalved = combinedColor * 0.5;
    vec3 param_3 = cameraPoint.xyz;
    vec3 param_4 = normal;
    vec2 _285 = posToTexCoord(param_3, param_4);
    vec2 envCoord = _285;
    vec3 param_5 = cameraPoint.xyz;
    vec3 param_6 = normal;
    float _292 = edgeScan(param_5, param_6);
    float edgeScanVal = _292;
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vec2(0.0);
    int uVertexShader = _230.vertexShader_IsAffectedByLight.x;
    #if (VERTEXSHADER == 0)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 1)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    #endif
    #if (VERTEXSHADER == 2)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 3)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    #endif
    #if (VERTEXSHADER == 4)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 5)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = envCoord;
    #endif
    #if (VERTEXSHADER == 6)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 7)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 8)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 9)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 10)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 11)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 12)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 13)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = envCoord;
    #endif
    #if (VERTEXSHADER == 14)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 15)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = vTexCoord3;
    #endif
    #if (VERTEXSHADER == 16)
    vec4 in_col0 = vec4(1.0);
    vDiffuseColor = vec4((in_col0.xyz * 0.5).x, (in_col0.xyz * 0.5).y, (in_col0.xyz * 0.5).z, in_col0.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vTexCoord3;
    #endif
    #if (VERTEXSHADER == 17)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 18)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    gl_Position = _239.scene.uPMatrix * cameraPoint;
    vNormal = normal;
    vPosition = cameraPoint.xyz;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _93;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
} _110;

layout(std140) uniform meshWideBlockVS
{
    ivec4 VertexShader_UseLitColor;
} _181;

layout(location = 0) in vec3 aPosition;
out vec4 vPosition;
layout(location = 5) in vec4 aColor;
out vec3 vNormal;
layout(location = 1) in vec3 aNormal;
out vec4 vColor;
out vec4 vColor2;
layout(location = 6) in vec4 aColor2;
out vec2 vTexCoord;
layout(location = 2) in vec2 aTexCoord;
out vec2 vTexCoord2;
layout(location = 3) in vec2 aTexCoord2;
out vec2 vTexCoord3;
layout(location = 4) in vec2 aTexCoord3;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(inout vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

void main()
{
    vec4 worldPoint = _93.uPlacementMat * vec4(aPosition, 1.0);
    vec4 cameraPoint = _110.scene.uLookAtMat * worldPoint;
    mat4 viewModelMat = _110.scene.uLookAtMat * _93.uPlacementMat;
    mat4 param = _110.scene.uLookAtMat;
    mat4 param_1 = _93.uPlacementMat;
    mat3 viewModelMatTransposed = blizzTranspose(param) * blizzTranspose(param_1);
    gl_Position = _110.scene.uPMatrix * cameraPoint;
    vPosition = vec4(cameraPoint.xyz, aColor.w);
    vNormal = normalize(viewModelMatTransposed * aNormal);
    vColor = vec4(0.5, 0.499989986419677734375, 0.5, 1.0);
    vColor2 = vec4(aColor.zyx * 2.0, aColor2.w);
    int uVertexShader = _181.VertexShader_UseLitColor.x;
    #if (VERTEXSHADER == (-1))
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 0)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 1)
    vTexCoord = aTexCoord;
    vTexCoord2 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 2)
    vTexCoord = aTexCoord;
    vec3 param_2 = vPosition.xyz;
    vec3 param_3 = vNormal;
    vec2 _234 = posToTexCoord(param_2, param_3);
    vTexCoord2 = _234;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 3)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 4)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 5)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    #endif
    #if (VERTEXSHADER == 6)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 7)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 8)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _19;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _29;

layout(location = 0) in vec3 aPosition;
out vec4 vPos;

void main()
{
    gl_Position = ((_19.uPMatrix * _19.uLookAtMat) * _29.uPlacementMat) * vec4(aPosition, 1.0);
    gl_PointSize = 10.0;
}


#version 330
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

uniform sampler2D Texture;

layout(location = 0) out vec4 Out_Color;
in vec4 Frag_Color;
in vec2 Frag_UV;

void main()
{
    Out_Color = Frag_Color * texture(Texture, Frag_UV);
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    mat4 ProjMtx;
} _30;

out vec2 Frag_UV;
layout(location = 1) in vec2 UV;
out vec4 Frag_Color;
layout(location = 2) in vec4 Color;
layout(location = 0) in vec2 Position;

void main()
{
    Frag_UV = UV;
    Frag_Color = Color;
    gl_Position = _30.ProjMtx * vec4(Position, 0.0, 1.0);
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _47;

layout(location = 0) in vec3 aPosition;
out vec4 vColor;
layout(location = 1) in vec4 aColor;
out vec2 vTexcoord0;
layout(location = 2) in vec2 aTexcoord0;
out vec2 vTexcoord1;
layout(location = 3) in vec2 aTexcoord1;
out vec2 vTexcoord2;
layout(location = 4) in vec2 aTexcoord2;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    vTexcoord1 = aTexcoord1;
    vTexcoord2 = aTexcoord2;
    gl_Position = (_47.uPMatrix * _47.uLookAtMat) * aPositionVec4;
}


#version 330

layout(std140) uniform modelWideBlockVS
{
    vec3 uPos;
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _55;

layout(location = 1) in float aIndex;
layout(location = 0) in float aHeight;
out vec2 vChunkCoords;
out vec3 vPosition;

void main()
{
    float stepX = floor(aIndex / 16641.0);
    float division = 129.0;
    if (stepX > 0.100000001490116119384765625)
    {
        division = 128.0;
    }
    float offset = (stepX * 129.0) * 129.0;
    float iX = mod(aIndex - offset, division) + (stepX * 0.5);
    float iY = floor((aIndex - offset) / division) + (stepX * 0.5);
    vec4 worldPoint = vec4(_55.uPos.x - (iY * 4.166666507720947265625), _55.uPos.y - (iX * 4.166666507720947265625), aHeight, 1.0);
    vChunkCoords = vec2(iX / 128.0, iY / 128.0);
    vPosition = (_55.uLookAtMat * worldPoint).xyz;
    gl_Position = (_55.uPMatrix * _55.uLookAtMat) * worldPoint;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

layout(std140) uniform meshWideBlockPS
{
    ivec4 UseLitColor_EnableAlpha_PixelShader;
    vec4 FogColor_AlphaTest;
} _220;

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
} _688;

layout(std140) uniform modelWideBlockPS
{
    InteriorLightParam intLight;
} _692;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

in vec2 vTexCoord;
in vec2 vTexCoord2;
in vec2 vTexCoord3;
in vec4 vColor;
in vec4 vColor2;
in vec3 vNormal;
in vec4 vPosition;
layout(location = 0) out vec4 outputColor;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight)
{
    vec3 localDiffuse = accumLight;
    if (!applyLight)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    vec3 currColor;
    if (intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        if (nDotUp >= 0.0)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    if (intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        if (intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = vec3(0.0);
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

void main()
{
    vec4 tex = texture(uTexture, vTexCoord);
    vec4 tex2 = texture(uTexture2, vTexCoord2);
    vec4 tex3 = texture(uTexture3, vTexCoord3);
    if (_220.UseLitColor_EnableAlpha_PixelShader.y == 1)
    {
        if ((tex.w - 0.501960813999176025390625) < 0.0)
        {
            discard;
        }
    }
    int uPixelShader = _220.UseLitColor_EnableAlpha_PixelShader.z;
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 matDiffuse = vec3(0.0);
    vec3 env = vec3(0.0);
    float finalOpacity = 0.0;
    #if (FRAGMENTSHADER == (-1))
    matDiffuse = (tex.xyz * vColor.xyz) + (tex2.xyz * vColor2.zyx);
    finalOpacity = tex.w;
    #endif
    #if (FRAGMENTSHADER == 0)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 1)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 2)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 3)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = tex2.xyz * tex.w;
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 4)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 5)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = (tex.xyz * tex.w) * tex2.xyz;
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 6)
    vec3 layer1 = tex.xyz;
    vec3 layer2 = mix(layer1, tex2.xyz, vec3(tex2.w));
    matDiffuse = (vColor.xyz * 2.0) * mix(layer2, layer1, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 7)
    vec4 colorMix = mix(tex2, tex, vec4(vColor2.w));
    matDiffuse = colorMix.xyz * (vColor.xyz * 2.0);
    env = (colorMix.xyz * colorMix.w) * tex3.xyz;
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 8)
    vec3 layer1_1 = tex.xyz;
    vec3 layer2_1 = tex2.xyz;
    matDiffuse = (vColor.xyz * 2.0) * mix(layer2_1, layer1_1, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 9)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = (tex2.xyz * tex2.w) * vColor2.w;
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 10)
    float mixFactor = clamp(tex3.w * vColor2.w, 0.0, 1.0);
    matDiffuse = (vColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(mixFactor)), tex.xyz, vec3(tex.w));
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 11)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = ((tex.xyz * tex.w) * tex2.xyz) + ((tex3.xyz * tex3.w) * vColor2.w);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 12)
    matDiffuse = (vColor.xyz * 2.0) * mix(tex2.xyz, tex.xyz, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 13)
    vec3 t1diffuse = tex2.xyz * (1.0 - tex2.w);
    matDiffuse = (vColor.xyz * 2.0) * mix(t1diffuse, tex.xyz, vec3(vColor2.w));
    env = (tex2.xyz * tex2.w) * (1.0 - vColor2.w);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 13)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 14)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 15)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 16)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 17)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 18)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 19)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = true;
    float param_3 = vPosition.w;
    SceneWideParams param_4;
    param_4.uLookAtMat = _688.scene.uLookAtMat;
    param_4.uPMatrix = _688.scene.uPMatrix;
    param_4.uViewUp = _688.scene.uViewUp;
    param_4.uInteriorSunDir = _688.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _688.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _688.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _688.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _688.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _688.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5;
    param_5.uInteriorAmbientColorAndApplyInteriorLight = _692.intLight.uInteriorAmbientColorAndApplyInteriorLight;
    param_5.uInteriorDirectColorAndApplyExteriorLight = _692.intLight.uInteriorDirectColorAndApplyExteriorLight;
    vec3 param_6 = vec3(0.0);
    finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vColor2.xyz), finalOpacity);
    if (finalColor.w < _220.FogColor_AlphaTest.w)
    {
        discard;
    }
    finalColor.w = 1.0;
    outputColor = finalColor;
}


#version 330

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

layout(std140) uniform sceneWideBlockVSPS
{
    SceneWideParams scene;
} _27;

layout(location = 0) in vec4 aPositionTransp;
out vec2 vTextCoords;
out vec3 vPosition;
layout(location = 1) in vec2 aTexCoord;

void main()
{
    vec4 aPositionVec4 = vec4(aPositionTransp.xyz, 1.0);
    mat4 cameraMatrix = _27.scene.uLookAtMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    vTextCoords = aPositionVec4.xy / vec2(33.333332061767578125);
    gl_Position = _27.scene.uPMatrix * cameraPoint;
    vPosition = cameraPoint.xyz;
}


#version 330

layout(std140) uniform sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
} _24;

layout(std140) uniform modelWideBlockVS
{
    mat4 uPlacementMat;
} _32;

layout(location = 0) in vec3 aPosition;
out vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    mat4 cameraMatrix = _24.uLookAtMat * _32.uPlacementMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    gl_Position = _24.uPMatrix * cameraPoint;
    vPosition = cameraPoint.xyz;
}


#version 330

layout(std140) uniform meshWideBlockPS
{
    float uWidth;
    float uHeight;
    float uX;
    float uY;
} _36;

out vec2 texCoord;
layout(location = 0) in vec2 position;
layout(location = 1) in vec2 _texture;

void main()
{
    texCoord = (position * 0.5) + vec2(0.5);
    gl_Position = vec4((((((position.x + 1.0) / 2.0) * _36.uWidth) + _36.uX) * 2.0) - 1.0, (((((position.y + 1.0) / 2.0) * _36.uHeight) + _36.uY) * 2.0) - 1.0, 0.0, 1.0);
}


#version 330
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

uniform sampler2D uTexture;

in vec2 vTexcoord0;
layout(location = 0) out vec4 outputColor;
in vec4 vColor;

void main()
{
    vec4 tex = texture(uTexture, vTexcoord0);
    outputColor = vec4(vColor.xyz * tex.xyz, tex.w * vColor.w);
}


#version 100

struct meshWideBlockPS
{
    int drawDepth;
    float uFarPlane;
    float uNearPlane;
};

uniform meshWideBlockPS _10;

uniform sampler2D diffuse;

varying vec2 texCoord;

void main()
{
    vec4 finalColor;
    if (_10.drawDepth == 1)
    {
        float f = _10.uFarPlane;
        float n = _10.uNearPlane;
        float z = (2.0 * n) / ((f + n) - (texture2D(diffuse, texCoord).x * (f - n)));
        finalColor = vec4(z, z, z, 255.0);
    }
    else
    {
        finalColor = vec4(texture2D(diffuse, texCoord).xyz, 255.0);
    }
    gl_FragData[0] = finalColor;
}


#version 100

struct meshWideBlockPS
{
    vec4 uAlphaTestv;
    ivec4 uPixelShaderv;
};

uniform meshWideBlockPS _38;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

varying vec2 vTexcoord0;
varying vec2 vTexcoord1;
varying vec2 vTexcoord2;
varying vec4 vColor;

void main()
{
    vec4 tex = texture2D(uTexture, vTexcoord0);
    vec4 tex2 = texture2D(uTexture2, vTexcoord1);
    vec4 tex3 = texture2D(uTexture3, vTexcoord2);
    float uAlphaTest = _38.uAlphaTestv.x;
    if (tex.w < uAlphaTest)
    {
        discard;
    }
    vec4 finalColor = vec4((tex * vColor).xyz, tex.w * vColor.w);
    int uNonOptPixelShader = _38.uPixelShaderv.x;
    if (uNonOptPixelShader == 0)
    {
        vec3 matDiffuse = vColor.xyz * tex.xyz;
        finalColor = vec4(matDiffuse, tex.w * vColor.w);
    }
    else
    {
        if (uNonOptPixelShader == 1)
        {
            vec4 textureMod = tex * tex2;
            float texAlpha = textureMod.w * tex3.w;
            float opacity = texAlpha * vColor.w;
            vec3 matDiffuse_1 = vColor.xyz * textureMod.xyz;
            finalColor = vec4(matDiffuse_1, opacity);
        }
        else
        {
            if (uNonOptPixelShader == 2)
            {
                vec4 textureMod_1 = (tex * tex2) * tex3;
                float texAlpha_1 = textureMod_1.w;
                float opacity_1 = texAlpha_1 * vColor.w;
                vec3 matDiffuse_2 = vColor.xyz * textureMod_1.xyz;
                finalColor = vec4(matDiffuse_2, opacity_1);
            }
            else
            {
                if (uNonOptPixelShader == 3)
                {
                    vec4 textureMod_2 = (tex * tex2) * tex3;
                    float texAlpha_2 = textureMod_2.w;
                    float opacity_2 = texAlpha_2 * vColor.w;
                    vec3 matDiffuse_3 = vColor.xyz * textureMod_2.xyz;
                    finalColor = vec4(matDiffuse_3, opacity_2);
                }
                else
                {
                    if (uNonOptPixelShader == 4)
                    {
                    }
                }
            }
        }
    }
    if (finalColor.w < uAlphaTest)
    {
        discard;
    }
    gl_FragData[0] = finalColor;
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _30;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
};

uniform modelWideBlockVS _40;

attribute vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4(aPosition, 1.0);
    gl_Position = ((_30.uPMatrix * _30.uLookAtMat) * _40.uPlacementMat) * worldPoint;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct LocalLight
{
    vec4 color;
    vec4 position;
    vec4 attenuation;
};

struct meshWideBlockPS
{
    ivec4 PixelShader_UnFogged_IsAffectedByLight;
    vec4 uFogColorAndAlphaTest;
    vec4 uPcColor;
};

uniform meshWideBlockPS _246;

struct modelWideBlockPS
{
    InteriorLightParam intLight;
    LocalLight pc_lights[4];
    ivec4 lightCount;
    vec4 interiorExteriorBlend;
};

uniform modelWideBlockPS _271;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
};

uniform sceneWideBlockVSPS _310;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
};

uniform modelWideBlockVS _318;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;
uniform sampler2D uTexture4;

varying vec2 vTexCoord;
varying vec2 vTexCoord2;
varying vec2 vTexCoord3;
varying vec4 vDiffuseColor;
varying vec3 vPosition;
varying vec3 vNormal;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight)
{
    vec3 localDiffuse = accumLight;
    if (!applyLight)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    vec3 currColor;
    if (intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        if (nDotUp >= 0.0)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    if (intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        if (intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = vec3(0.0);
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

void main()
{
    vec2 texCoord = vTexCoord;
    vec2 texCoord2 = vTexCoord2;
    vec2 texCoord3 = vTexCoord3;
    vec4 tex = texture2D(uTexture, texCoord);
    vec4 tex2 = texture2D(uTexture2, texCoord2);
    vec4 tex3 = texture2D(uTexture3, texCoord3);
    vec4 tex2WithTextCoord1 = texture2D(uTexture2, texCoord);
    vec4 tex3WithTextCoord1 = texture2D(uTexture3, texCoord);
    vec4 tex4WithTextCoord2 = texture2D(uTexture4, texCoord2);
    vec4 finalColor = vec4(0.0);
    vec4 meshResColor = vDiffuseColor;
    vec3 accumLight;
    if (_246.PixelShader_UnFogged_IsAffectedByLight.z == 1)
    {
        vec3 vPos3 = vPosition;
        vec3 vNormal3 = normalize(vNormal);
        vec3 lightColor = vec3(0.0);
        int count = int(_271.pc_lights[0].attenuation.w);
        LocalLight lightRecord;
        for (int index = 0; index < 4; index++)
        {
            if (index >= _271.lightCount.x)
            {
                break;
            }
            lightRecord.color = _271.pc_lights[index].color;
            lightRecord.position = _271.pc_lights[index].position;
            lightRecord.attenuation = _271.pc_lights[index].attenuation;
            vec3 vectorToLight = (_310.scene.uLookAtMat * (_318.uPlacementMat * lightRecord.position)).xyz - vPos3;
            float distanceToLightSqr = dot(vectorToLight, vectorToLight);
            float distanceToLightInv = inversesqrt(distanceToLightSqr);
            float distanceToLight = distanceToLightSqr * distanceToLightInv;
            float diffuseTerm1 = max(dot(vectorToLight, vNormal3) * distanceToLightInv, 0.0);
            vec4 attenuationRec = lightRecord.attenuation;
            float attenuation = 1.0 - clamp((distanceToLight - attenuationRec.x) * (1.0 / (attenuationRec.z - attenuationRec.x)), 0.0, 1.0);
            vec3 attenuatedColor = (lightRecord.color.xyz * attenuation) * attenuationRec.y;
            lightColor += vec3((attenuatedColor * attenuatedColor) * diffuseTerm1);
        }
        vec3 _389 = clamp(lightColor, vec3(0.0), vec3(1.0));
        meshResColor = vec4(_389.x, _389.y, _389.z, meshResColor.w);
        accumLight = meshResColor.xyz;
    }
    float finalOpacity = 0.0;
    vec3 specular = vec3(0.0);
    vec3 visParams = vec3(1.0);
    vec4 genericParams[3];
    genericParams[0] = vec4(1.0);
    genericParams[1] = vec4(1.0);
    genericParams[2] = vec4(1.0);
    int uPixelShader = _246.PixelShader_UnFogged_IsAffectedByLight.x;
    vec3 matDiffuse;
    float opacity;
    #if (FRAGMENTSHADER == 0)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 1)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 2)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = tex2.w * vDiffuseColor.w;
    opacity = tex2.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 3)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = (tex2.w * 2.0) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 4)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 5)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 6)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = (tex.w * tex2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 7)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = ((tex.w * tex2.w) * 2.0) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 8)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + tex2.w) * vDiffuseColor.w;
    specular = tex2.xyz;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 9)
    matDiffuse = (((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz) * 2.0;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 10)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = tex2.xyz;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 11)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * tex2.xyz;
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 12)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 13)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = tex2.xyz * tex2.w;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 14)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 15)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w));
    specular = (tex3.xyz * tex3.w) * genericParams[0].z;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 16)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = tex2.xyz * tex2.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 17)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + (tex2.w * (((0.300000011920928955078125 * tex2.x) + (0.589999973773956298828125 * tex2.y)) + (0.10999999940395355224609375 * tex2.z)))) * vDiffuseColor.w;
    specular = (tex2.xyz * tex2.w) * (1.0 - tex.w);
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 18)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex.xyz, tex2.xyz, vec3(tex2.w)), tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 19)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 20)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    specular = (tex2.xyz * tex2.w) * genericParams[0].y;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 21)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w + tex2.w) * vDiffuseColor.w;
    specular = tex2.xyz * (1.0 - tex.w);
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 22)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * tex2.xyz, tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 23)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = tex.w * vDiffuseColor.w;
    specular = (tex2.xyz * tex2.w) * genericParams[0].y;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 24)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    specular = (tex.xyz * tex.w) * genericParams[0].x;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 25)
    float glowOpacity = clamp(tex3.w * genericParams[0].z, 0.0, 1.0);
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * mix((tex.xyz * tex2.xyz) * 2.0, tex.xyz, vec3(tex.w))) * (1.0 - glowOpacity);
    specular = tex3.xyz * glowOpacity;
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 26)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).xyz;
    opacity = mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 27)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(tex3.w)), tex.xyz, vec3(tex.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 28)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).xyz;
    opacity = (mix(mix(tex, tex2WithTextCoord1, vec4(clamp(genericParams[0].y, 0.0, 1.0))), tex3WithTextCoord1, vec4(clamp(genericParams[0].z, 0.0, 1.0))).w * tex4WithTextCoord2.w) * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 29)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz, tex2.xyz, vec3(tex2.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 30)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 31)
    matDiffuse = ((vDiffuseColor.xyz * 2.0) * tex.xyz) * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w));
    opacity = tex.w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 32)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * mix(tex.xyz * mix(genericParams[0].xyz, tex2.xyz * genericParams[1].xyz, vec3(tex2.w)), tex3.xyz * genericParams[2].xyz, vec3(tex3.w));
    opacity = vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 33)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * tex.xyz;
    opacity = (tex.w * vDiffuseColor.w) * visParams.x;
    finalOpacity = opacity * visParams.x;
    #endif
    #if (FRAGMENTSHADER == 34)
    finalColor = vec4(1.0);
    #endif
    #if (FRAGMENTSHADER == 35)
    matDiffuse = (vDiffuseColor.xyz * 2.0) * (((tex * tex2) * tex3) * genericParams[0]).xyz;
    opacity = (((tex * tex2) * tex3) * genericParams[0]).w * vDiffuseColor.w;
    finalOpacity = opacity * visParams.x;
    #endif
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = _246.PixelShader_UnFogged_IsAffectedByLight.z > 0;
    float param_3 = _271.interiorExteriorBlend.x;
    SceneWideParams param_4;
    param_4.uLookAtMat = _310.scene.uLookAtMat;
    param_4.uPMatrix = _310.scene.uPMatrix;
    param_4.uViewUp = _310.scene.uViewUp;
    param_4.uInteriorSunDir = _310.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _310.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _310.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _310.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _310.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _310.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5;
    param_5.uInteriorAmbientColorAndApplyInteriorLight = _271.intLight.uInteriorAmbientColorAndApplyInteriorLight;
    param_5.uInteriorDirectColorAndApplyExteriorLight = _271.intLight.uInteriorDirectColorAndApplyExteriorLight;
    vec3 param_6 = accumLight;
    finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vec3(0.0)), finalOpacity);
    if (finalColor.w < _246.uFogColorAndAlphaTest.w)
    {
        discard;
    }
    gl_FragData[0] = finalColor;
}


#version 100

struct modelWideBlockVS
{
    vec3 uColor;
};

uniform modelWideBlockVS _13;

varying vec4 vPos;

void main()
{
    gl_FragData[0] = vec4(_13.uColor, 1.0);
}


#version 100

struct meshWideBlockPS
{
    vec4 color;
};

uniform meshWideBlockPS _12;

uniform sampler2D uTexture;

varying vec2 vTextCoords;
varying vec3 vPosition;

void main()
{
    gl_FragData[0] = vec4(_12.color.xyz * texture2D(uTexture, vTextCoords).xyz, 0.699999988079071044921875);
}


#version 100

struct modelWideBlockVS
{
    mat4 uPlacementMat;
    vec4 uBBScale;
    vec4 uBBCenter;
    vec4 uColor;
};

uniform modelWideBlockVS _13;

void main()
{
    vec4 finalColor = _13.uColor;
    gl_FragData[0] = finalColor;
}


#version 100

struct modelWideBlockPS
{
    vec3 uColor;
};

uniform modelWideBlockPS _19;

void main()
{
    vec4 finalColor = vec4(1.0, 1.0, 0.0, 1.0);
    gl_FragData[0] = finalColor;
}


#version 100

struct modelWideBlockVS
{
    vec4 uColor;
};

uniform modelWideBlockVS _12;

void main()
{
    vec4 finalColor = _12.uColor;
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
};

uniform sceneWideBlockVSPS _43;

attribute vec3 aPosition;
varying vec4 vColor;
attribute vec4 aColor;
varying vec2 vTexcoord0;
attribute vec2 aTexcoord0;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    gl_Position = (_43.scene.uPMatrix * _43.scene.uLookAtMat) * aPositionVec4;
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _13;

attribute vec3 aPosition;

void main()
{
    vec4 c_world = inverse(_13.uPMatrix) * vec4(aPosition, 1.0);
    c_world = (c_world * 1.0) / vec4(c_world.w);
    gl_Position = (_13.uPMatrix * _13.uLookAtMat) * vec4(c_world.xyz, 1.0);
}


#version 100
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

attribute vec4 a_position;
varying vec2 v_texcoord;

void main()
{
    gl_Position = a_position;
    v_texcoord = (a_position.xy * 0.5) + vec2(0.5);
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _19;

attribute vec2 aPosition;

void main()
{
    gl_Position = (_19.uPMatrix * _19.uLookAtMat) * vec4(aPosition, 0.0, 1.0);
}


#version 100

struct modelWideBlockVS
{
    mat4 uPlacementMat;
    vec4 uBBScale;
    vec4 uBBCenter;
    vec4 uColor;
};

uniform modelWideBlockVS _21;

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _59;

attribute vec3 aPosition;

void main()
{
    vec4 worldPoint = vec4((aPosition.x * _21.uBBScale.x) + _21.uBBCenter.x, (aPosition.y * _21.uBBScale.y) + _21.uBBCenter.y, (aPosition.z * _21.uBBScale.z) + _21.uBBCenter.z, 1.0);
    gl_Position = ((_59.uPMatrix * _59.uLookAtMat) * _21.uPlacementMat) * worldPoint;
}


#version 100

struct meshWideBlockPS
{
    ivec4 waterTypeV;
};

uniform meshWideBlockPS _12;

uniform sampler2D uTexture;

varying vec3 vPosition;

void main()
{
    int waterType = _12.waterTypeV.x;
    if (waterType == 13)
    {
        gl_FragData[0] = vec4(0.0, 0.0, 0.300000011920928955078125, 0.5);
    }
    else
    {
        if (waterType == 14)
        {
            gl_FragData[0] = vec4(0.0, 0.0, 0.800000011920928955078125, 0.800000011920928955078125);
        }
        else
        {
            if (waterType == 19)
            {
                gl_FragData[0] = vec4(0.300000011920928955078125, 0.0, 0.0, 0.5);
            }
            else
            {
                if (waterType == 20)
                {
                    gl_FragData[0] = vec4(0.0, 0.5, 0.0, 0.5);
                }
                else
                {
                    gl_FragData[0] = vec4(0.5);
                }
            }
        }
    }
}


#version 100

struct modelWideBlockPS
{
    vec4 uViewUp;
    vec4 uSunDir_FogStart;
    vec4 uSunColor_uFogEnd;
    vec4 uAmbientLight;
    vec4 FogColor;
    int uNewFormula;
};

uniform modelWideBlockPS _65;

uniform sampler2D uDiffuseTexture;
uniform sampler2D uNormalTexture;

varying vec2 vChunkCoords;
varying vec3 vPosition;

void main()
{
    vec2 TextureCoords = vec2(vChunkCoords.x, vChunkCoords.y);
    vec4 texDiffuse = texture2D(uDiffuseTexture, TextureCoords);
    vec3 matDiffuse = texDiffuse.xyz;
    vec3 vNormal = (texture2D(uNormalTexture, TextureCoords).xyz * 2.0) - vec3(1.0);
    vNormal = vec3(-vNormal.z, -vNormal.x, vNormal.y);
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 fogColor = _65.FogColor.xyz;
    float fog_start = _65.uSunDir_FogStart.w;
    float fog_end = _65.uSunColor_uFogEnd.w;
    float fog_rate = 1.5;
    float fog_bias = 0.00999999977648258209228515625;
    float distanceToCamera = length(vPosition);
    float z_depth = distanceToCamera - fog_bias;
    float expFog = 1.0 / exp(max(0.0, z_depth - fog_start) * fog_rate);
    float heightFog = 1.0;
    expFog += heightFog;
    float endFadeFog = clamp((fog_end - distanceToCamera) / (0.699999988079071044921875 * fog_end), 0.0, 1.0);
    vec3 _123 = mix(fogColor, finalColor.xyz, vec3(min(expFog, endFadeFog)));
    finalColor = vec4(_123.x, _123.y, _123.z, finalColor.w);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

struct meshWideBlockPS
{
    float gauss_offsets[5];
    float gauss_weights[5];
    vec2 uResolution;
};

uniform meshWideBlockPS _34;

uniform sampler2D u_sampler;
uniform sampler2D u_depth;

varying vec2 v_texcoord;

void main()
{
    float FXAA_SPAN_MAX = 8.0;
    float FXAA_REDUCE_MUL = 0.125;
    float FXAA_REDUCE_MIN = 0.0078125;
    vec3 rgbNW = texture2D(u_sampler, v_texcoord + (vec2(-1.0) / _34.uResolution)).xyz;
    vec3 rgbNE = texture2D(u_sampler, v_texcoord + (vec2(1.0, -1.0) / _34.uResolution)).xyz;
    vec3 rgbSW = texture2D(u_sampler, v_texcoord + (vec2(-1.0, 1.0) / _34.uResolution)).xyz;
    vec3 rgbSE = texture2D(u_sampler, v_texcoord + (vec2(1.0) / _34.uResolution)).xyz;
    vec3 rgbM = texture2D(u_sampler, v_texcoord).xyz;
    vec3 luma = vec3(0.2989999949932098388671875, 0.58700001239776611328125, 0.114000000059604644775390625);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM = dot(rgbM, luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y = (lumaNW + lumaSW) - (lumaNE + lumaSE);
    float dirReduce = max((((lumaNW + lumaNE) + lumaSW) + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * rcpDirMin)) / _34.uResolution;
    vec3 rgbA = (texture2D(u_sampler, v_texcoord + (dir * (-0.16666667163372039794921875))).xyz + texture2D(u_sampler, v_texcoord + (dir * 0.16666667163372039794921875)).xyz) * 0.5;
    vec3 rgbB = (rgbA * 0.5) + ((texture2D(u_sampler, v_texcoord + (dir * (-0.5))).xyz + texture2D(u_sampler, v_texcoord + (dir * 0.5)).xyz) * 0.25);
    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
    {
        gl_FragData[0] = vec4(rgbA.x, rgbA.y, rgbA.z, gl_FragData[0].w);
    }
    else
    {
        gl_FragData[0] = vec4(rgbB.x, rgbB.y, rgbB.z, gl_FragData[0].w);
    }
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
};

uniform sceneWideBlockVSPS _90;

struct meshWideBlockVS
{
    vec4 uPos;
};

uniform meshWideBlockVS _130;

attribute float aIndex;
attribute vec3 aHeight;
varying vec2 vChunkCoords;
varying vec3 vPosition;
varying vec4 vColor;
attribute vec4 aColor;
varying vec3 vVertexLighting;
attribute vec4 aVertexLighting;
varying vec3 vNormal;
attribute vec3 aNormal;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

void main()
{
    float iX = mod(aIndex, 17.0);
    float iY = floor(aIndex / 17.0);
    if (iX > 8.0100002288818359375)
    {
        iY += 0.5;
        iX -= 8.5;
    }
    vec4 worldPoint = vec4(aHeight, 1.0);
    vChunkCoords = vec2(iX, iY);
    vPosition = (_90.scene.uLookAtMat * worldPoint).xyz;
    vColor = aColor;
    vVertexLighting = aVertexLighting.xyz;
    mat4 param = _90.scene.uLookAtMat;
    vNormal = blizzTranspose(param) * aNormal;
    gl_Position = (_90.scene.uPMatrix * _90.scene.uLookAtMat) * worldPoint;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct meshWideBlockPS
{
    vec4 uHeightScale;
    vec4 uHeightOffset;
};

uniform meshWideBlockPS _251;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
};

uniform sceneWideBlockVSPS _427;

struct modelWideBlockPS
{
    vec4 uFogStartAndFogEnd;
    vec4 uFogColor;
};

uniform modelWideBlockPS _514;

uniform sampler2D uAlphaTexture;
uniform sampler2D uLayerHeight0;
uniform sampler2D uLayerHeight1;
uniform sampler2D uLayerHeight2;
uniform sampler2D uLayerHeight3;
uniform sampler2D uLayer0;
uniform sampler2D uLayer1;
uniform sampler2D uLayer2;
uniform sampler2D uLayer3;

varying vec2 vChunkCoords;
varying vec4 vColor;
varying vec3 vNormal;
varying vec3 vVertexLighting;
varying vec3 vPosition;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight)
{
    vec3 localDiffuse = accumLight;
    if (!applyLight)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    vec3 currColor;
    if (intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        if (nDotUp >= 0.0)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    if (intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        if (intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = vec3(0.0);
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

void main()
{
    vec2 vTexCoord = vChunkCoords;
    vec2 alphaCoord = vec2(vChunkCoords.x / 8.0, vChunkCoords.y / 8.0);
    vec3 alphaBlend = texture2D(uAlphaTexture, alphaCoord).yzw;
    vec2 tcLayer0 = vTexCoord;
    vec2 tcLayer1 = vTexCoord;
    vec2 tcLayer2 = vTexCoord;
    vec2 tcLayer3 = vTexCoord;
    float minusAlphaBlendSum = 1.0 - clamp(dot(alphaBlend, vec3(1.0)), 0.0, 1.0);
    vec4 weightsVector = vec4(minusAlphaBlendSum, alphaBlend);
    float weightedTexture_x = minusAlphaBlendSum * ((texture2D(uLayerHeight0, tcLayer0).w * _251.uHeightScale.x) + _251.uHeightOffset.x);
    float weightedTexture_y = weightsVector.y * ((texture2D(uLayerHeight1, tcLayer1).w * _251.uHeightScale.y) + _251.uHeightOffset.y);
    float weightedTexture_z = weightsVector.z * ((texture2D(uLayerHeight2, tcLayer2).w * _251.uHeightScale.z) + _251.uHeightOffset.z);
    float weightedTexture_w = weightsVector.w * ((texture2D(uLayerHeight3, tcLayer3).w * _251.uHeightScale.w) + _251.uHeightOffset.w);
    vec4 weights = vec4(weightedTexture_x, weightedTexture_y, weightedTexture_z, weightedTexture_w);
    vec4 weights_temp = weights * (vec4(1.0) - clamp(vec4(max(max(weightedTexture_x, weightedTexture_y), max(weightedTexture_z, weightedTexture_w))) - weights, vec4(0.0), vec4(1.0)));
    vec4 weightsNormalized = weights_temp / vec4(dot(vec4(1.0), weights_temp));
    vec4 weightedLayer_0 = texture2D(uLayer0, tcLayer0) * weightsNormalized.x;
    vec3 matDiffuse_0 = weightedLayer_0.xyz;
    float specBlend_0 = weightedLayer_0.w;
    vec4 weightedLayer_1 = texture2D(uLayer1, tcLayer1) * weightsNormalized.y;
    vec3 matDiffuse_1 = matDiffuse_0 + weightedLayer_1.xyz;
    float specBlend_1 = specBlend_0 + weightedLayer_1.w;
    vec4 weightedLayer_2 = texture2D(uLayer2, tcLayer1) * weightsNormalized.z;
    vec3 matDiffuse_2 = matDiffuse_1 + weightedLayer_2.xyz;
    float specBlend_2 = specBlend_1 + weightedLayer_2.w;
    vec4 weightedLayer_3 = texture2D(uLayer3, tcLayer1) * weightsNormalized.w;
    vec3 matDiffuse_3 = matDiffuse_2 + weightedLayer_3.xyz;
    float specBlend_3 = specBlend_2 + weightedLayer_3.w;
    vec4 final = vec4(matDiffuse_3, specBlend_3);
    vec3 matDiffuse = final.xyz * vColor.xyz;
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = true;
    float param_3 = 0.0;
    SceneWideParams param_4;
    param_4.uLookAtMat = _427.scene.uLookAtMat;
    param_4.uPMatrix = _427.scene.uPMatrix;
    param_4.uViewUp = _427.scene.uViewUp;
    param_4.uInteriorSunDir = _427.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _427.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _427.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _427.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _427.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _427.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5 = InteriorLightParam(vec4(0.0), vec4(0.0, 0.0, 0.0, 1.0));
    vec3 param_6 = vVertexLighting;
    vec4 finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vec3(0.0)), 1.0);
    float specBlend = final.w;
    vec3 halfVec = -normalize(_427.scene.extLight.uExteriorDirectColorDir.xyz + normalize(vPosition));
    vec3 lSpecular = _427.scene.extLight.uExteriorDirectColor.xyz * pow(max(0.0, dot(halfVec, vNormal)), 20.0);
    vec3 specTerm = vec3(specBlend) * lSpecular;
    vec3 _505 = finalColor.xyz + specTerm;
    finalColor = vec4(_505.x, _505.y, _505.z, finalColor.w);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

struct meshWideBlockPS
{
    vec3 uColor;
};

uniform meshWideBlockPS _22;

void main()
{
    vec4 finalColor = vec4(1.0);
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct modelWideBlockVS
{
    mat4 uPlacementMat;
    mat4 uBoneMatrixes[220];
};

uniform modelWideBlockVS _133;

struct meshWideBlockVS
{
    ivec4 vertexShader_IsAffectedByLight;
    vec4 color_Transparency;
    mat4 uTextMat[2];
};

uniform meshWideBlockVS _230;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
};

uniform sceneWideBlockVSPS _239;

attribute vec3 aPosition;
attribute vec4 boneWeights;
attribute vec4 bones;
attribute vec3 aNormal;
varying vec2 vTexCoord2;
varying vec2 vTexCoord3;
varying vec4 vDiffuseColor;
varying vec2 vTexCoord;
attribute vec2 aTexCoord;
attribute vec2 aTexCoord2;
varying vec3 vNormal;
varying vec3 vPosition;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(inout vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

float edgeScan(inout vec3 position, vec3 normal)
{
    float dotProductClamped = clamp(dot(-normalize(position), normal), 0.0, 1.0);
    return clamp(((2.7000000476837158203125 * dotProductClamped) * dotProductClamped) - 0.4000000059604644775390625, 0.0, 1.0);
}

void main()
{
    vec4 modelPoint = vec4(0.0);
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    mat4 boneTransformMat = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(0.0));
    mat4 _143 = _133.uBoneMatrixes[bones.x] * boneWeights.x;
    boneTransformMat = mat4(boneTransformMat[0] + _143[0], boneTransformMat[1] + _143[1], boneTransformMat[2] + _143[2], boneTransformMat[3] + _143[3]);
    mat4 _164 = _133.uBoneMatrixes[bones.y] * boneWeights.y;
    boneTransformMat = mat4(boneTransformMat[0] + _164[0], boneTransformMat[1] + _164[1], boneTransformMat[2] + _164[2], boneTransformMat[3] + _164[3]);
    mat4 _185 = _133.uBoneMatrixes[bones.z] * boneWeights.z;
    boneTransformMat = mat4(boneTransformMat[0] + _185[0], boneTransformMat[1] + _185[1], boneTransformMat[2] + _185[2], boneTransformMat[3] + _185[3]);
    mat4 _207 = _133.uBoneMatrixes[bones.w] * boneWeights.w;
    boneTransformMat = mat4(boneTransformMat[0] + _207[0], boneTransformMat[1] + _207[1], boneTransformMat[2] + _207[2], boneTransformMat[3] + _207[3]);
    mat4 placementMat = _133.uPlacementMat;
    vec4 lDiffuseColor = _230.color_Transparency;
    mat4 cameraMatrix = (_239.scene.uLookAtMat * placementMat) * boneTransformMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    mat4 param = _239.scene.uLookAtMat;
    mat4 param_1 = placementMat;
    mat4 param_2 = boneTransformMat;
    mat3 viewModelMatTransposed = (blizzTranspose(param) * blizzTranspose(param_1)) * blizzTranspose(param_2);
    vec3 normal = normalize(viewModelMatTransposed * aNormal);
    vec4 combinedColor = clamp(lDiffuseColor, vec4(0.0), vec4(1.0));
    vec4 combinedColorHalved = combinedColor * 0.5;
    vec3 param_3 = cameraPoint.xyz;
    vec3 param_4 = normal;
    vec2 _285 = posToTexCoord(param_3, param_4);
    vec2 envCoord = _285;
    vec3 param_5 = cameraPoint.xyz;
    vec3 param_6 = normal;
    float _292 = edgeScan(param_5, param_6);
    float edgeScanVal = _292;
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vec2(0.0);
    int uVertexShader = _230.vertexShader_IsAffectedByLight.x;
    #if (VERTEXSHADER == 0)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 1)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    #endif
    #if (VERTEXSHADER == 2)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 3)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    #endif
    #if (VERTEXSHADER == 4)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 5)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = envCoord;
    vTexCoord2 = envCoord;
    #endif
    #if (VERTEXSHADER == 6)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 7)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 8)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 9)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 10)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 11)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = envCoord;
    vTexCoord3 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 12)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 13)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w * edgeScanVal);
    vTexCoord = envCoord;
    #endif
    #if (VERTEXSHADER == 14)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 15)
    vDiffuseColor = vec4(combinedColorHalved.x, combinedColorHalved.y, combinedColorHalved.z, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    vTexCoord2 = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord3 = vTexCoord3;
    #endif
    #if (VERTEXSHADER == 16)
    vec4 in_col0 = vec4(1.0);
    vDiffuseColor = vec4((in_col0.xyz * 0.5).x, (in_col0.xyz * 0.5).y, (in_col0.xyz * 0.5).z, in_col0.w);
    vTexCoord = (_230.uTextMat[1] * vec4(aTexCoord2, 0.0, 1.0)).xy;
    vTexCoord2 = vec2(0.0);
    vTexCoord3 = vTexCoord3;
    #endif
    #if (VERTEXSHADER == 17)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    #if (VERTEXSHADER == 18)
    vDiffuseColor = vec4(combinedColor.xyz * 0.5, combinedColor.w);
    vTexCoord = (_230.uTextMat[0] * vec4(aTexCoord, 0.0, 1.0)).xy;
    #endif
    gl_Position = _239.scene.uPMatrix * cameraPoint;
    vNormal = normal;
    vPosition = cameraPoint.xyz;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct modelWideBlockVS
{
    mat4 uPlacementMat;
};

uniform modelWideBlockVS _93;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
};

uniform sceneWideBlockVSPS _110;

struct meshWideBlockVS
{
    ivec4 VertexShader_UseLitColor;
};

uniform meshWideBlockVS _181;

attribute vec3 aPosition;
varying vec4 vPosition;
attribute vec4 aColor;
varying vec3 vNormal;
attribute vec3 aNormal;
varying vec4 vColor;
varying vec4 vColor2;
attribute vec4 aColor2;
varying vec2 vTexCoord;
attribute vec2 aTexCoord;
varying vec2 vTexCoord2;
attribute vec2 aTexCoord2;
varying vec2 vTexCoord3;
attribute vec2 aTexCoord3;

mat3 blizzTranspose(mat4 value)
{
    return mat3(vec3(value[0].xyz), vec3(value[1].xyz), vec3(value[2].xyz));
}

vec2 posToTexCoord(inout vec3 cameraPoint, vec3 normal)
{
    vec3 normPos_495 = normalize(cameraPoint);
    vec3 temp_500 = normPos_495 - (normal * (2.0 * dot(normPos_495, normal)));
    vec3 temp_657 = vec3(temp_500.x, temp_500.y, temp_500.z + 1.0);
    return (normalize(temp_657).xy * 0.5) + vec2(0.5);
}

void main()
{
    vec4 worldPoint = _93.uPlacementMat * vec4(aPosition, 1.0);
    vec4 cameraPoint = _110.scene.uLookAtMat * worldPoint;
    mat4 viewModelMat = _110.scene.uLookAtMat * _93.uPlacementMat;
    mat4 param = _110.scene.uLookAtMat;
    mat4 param_1 = _93.uPlacementMat;
    mat3 viewModelMatTransposed = blizzTranspose(param) * blizzTranspose(param_1);
    gl_Position = _110.scene.uPMatrix * cameraPoint;
    vPosition = vec4(cameraPoint.xyz, aColor.w);
    vNormal = normalize(viewModelMatTransposed * aNormal);
    vColor = vec4(0.5, 0.499989986419677734375, 0.5, 1.0);
    vColor2 = vec4(aColor.zyx * 2.0, aColor2.w);
    int uVertexShader = _181.VertexShader_UseLitColor.x;
    #if (VERTEXSHADER == (-1))
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 0)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 1)
    vTexCoord = aTexCoord;
    vTexCoord2 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 2)
    vTexCoord = aTexCoord;
    vec3 param_2 = vPosition.xyz;
    vec3 param_3 = vNormal;
    vec2 _234 = posToTexCoord(param_2, param_3);
    vTexCoord2 = _234;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 3)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 4)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 5)
    vTexCoord = aTexCoord;
    vTexCoord2 = aTexCoord2;
    vTexCoord3 = reflect(normalize(cameraPoint.xyz), vNormal).xy;
    #endif
    #if (VERTEXSHADER == 6)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 7)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
    #if (VERTEXSHADER == 8)
    vTexCoord = aTexCoord;
    vTexCoord2 = vPosition.xy * (-0.23999999463558197021484375);
    vTexCoord3 = aTexCoord3;
    #endif
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _19;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
};

uniform modelWideBlockVS _29;

attribute vec3 aPosition;
varying vec4 vPos;

void main()
{
    gl_Position = ((_19.uPMatrix * _19.uLookAtMat) * _29.uPlacementMat) * vec4(aPosition, 1.0);
    gl_PointSize = 10.0;
}


#version 100
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

uniform sampler2D Texture;

varying vec4 Frag_Color;
varying vec2 Frag_UV;

void main()
{
    gl_FragData[0] = Frag_Color * texture2D(Texture, Frag_UV);
}


#version 100

struct modelWideBlockVS
{
    mat4 ProjMtx;
};

uniform modelWideBlockVS _30;

varying vec2 Frag_UV;
attribute vec2 UV;
varying vec4 Frag_Color;
attribute vec4 Color;
attribute vec2 Position;

void main()
{
    Frag_UV = UV;
    Frag_Color = Color;
    gl_Position = _30.ProjMtx * vec4(Position, 0.0, 1.0);
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _47;

attribute vec3 aPosition;
varying vec4 vColor;
attribute vec4 aColor;
varying vec2 vTexcoord0;
attribute vec2 aTexcoord0;
varying vec2 vTexcoord1;
attribute vec2 aTexcoord1;
varying vec2 vTexcoord2;
attribute vec2 aTexcoord2;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    vColor = aColor;
    vTexcoord0 = aTexcoord0;
    vTexcoord1 = aTexcoord1;
    vTexcoord2 = aTexcoord2;
    gl_Position = (_47.uPMatrix * _47.uLookAtMat) * aPositionVec4;
}


#version 100

struct modelWideBlockVS
{
    vec3 uPos;
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform modelWideBlockVS _55;

attribute float aIndex;
attribute float aHeight;
varying vec2 vChunkCoords;
varying vec3 vPosition;

void main()
{
    float stepX = floor(aIndex / 16641.0);
    float division = 129.0;
    if (stepX > 0.100000001490116119384765625)
    {
        division = 128.0;
    }
    float offset = (stepX * 129.0) * 129.0;
    float iX = mod(aIndex - offset, division) + (stepX * 0.5);
    float iY = floor((aIndex - offset) / division) + (stepX * 0.5);
    vec4 worldPoint = vec4(_55.uPos.x - (iY * 4.166666507720947265625), _55.uPos.y - (iX * 4.166666507720947265625), aHeight, 1.0);
    vChunkCoords = vec2(iX / 128.0, iY / 128.0);
    vPosition = (_55.uLookAtMat * worldPoint).xyz;
    gl_Position = (_55.uPMatrix * _55.uLookAtMat) * worldPoint;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct InteriorLightParam
{
    vec4 uInteriorAmbientColorAndApplyInteriorLight;
    vec4 uInteriorDirectColorAndApplyExteriorLight;
};

struct meshWideBlockPS
{
    ivec4 UseLitColor_EnableAlpha_PixelShader;
    vec4 FogColor_AlphaTest;
};

uniform meshWideBlockPS _220;

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
};

uniform sceneWideBlockVSPS _688;

struct modelWideBlockPS
{
    InteriorLightParam intLight;
};

uniform modelWideBlockPS _692;

uniform sampler2D uTexture;
uniform sampler2D uTexture2;
uniform sampler2D uTexture3;

varying vec2 vTexCoord;
varying vec2 vTexCoord2;
varying vec2 vTexCoord3;
varying vec4 vColor;
varying vec4 vColor2;
varying vec3 vNormal;
varying vec4 vPosition;

vec3 calcLight(vec3 matDiffuse, vec3 vNormal_1, bool applyLight, float interiorExteriorBlend, SceneWideParams sceneParams, InteriorLightParam intLight, vec3 accumLight, vec3 precomputedLight)
{
    vec3 localDiffuse = accumLight;
    if (!applyLight)
    {
        return matDiffuse;
    }
    vec3 lDiffuse = vec3(0.0);
    vec3 normalizedN = normalize(vNormal_1);
    vec3 currColor;
    if (intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0)
    {
        float nDotL = clamp(dot(normalizedN, -sceneParams.extLight.uExteriorDirectColorDir.xyz), 0.0, 1.0);
        float nDotUp = dot(normalizedN, sceneParams.uViewUp.xyz);
        vec3 adjAmbient = sceneParams.extLight.uExteriorAmbientColor.xyz + precomputedLight;
        vec3 adjHorizAmbient = sceneParams.extLight.uExteriorHorizontAmbientColor.xyz + precomputedLight;
        vec3 adjGroundAmbient = sceneParams.extLight.uExteriorGroundAmbientColor.xyz + precomputedLight;
        if (nDotUp >= 0.0)
        {
            currColor = mix(adjHorizAmbient, adjAmbient, vec3(nDotUp));
        }
        else
        {
            currColor = mix(adjHorizAmbient, adjGroundAmbient, vec3(-nDotUp));
        }
        vec3 skyColor = currColor * 1.10000002384185791015625;
        vec3 groundColor = currColor * 0.699999988079071044921875;
        lDiffuse = sceneParams.extLight.uExteriorDirectColor.xyz * nDotL;
        currColor = mix(groundColor, skyColor, vec3(0.5 + (0.5 * nDotL)));
    }
    if (intLight.uInteriorAmbientColorAndApplyInteriorLight.w > 0.0)
    {
        float nDotL_1 = clamp(dot(normalizedN, -sceneParams.uInteriorSunDir.xyz), 0.0, 1.0);
        vec3 lDiffuseInterior = intLight.uInteriorDirectColorAndApplyExteriorLight.xyz * nDotL_1;
        vec3 interiorAmbient = intLight.uInteriorAmbientColorAndApplyInteriorLight.xyz + precomputedLight;
        if (intLight.uInteriorDirectColorAndApplyExteriorLight.w > 0.0)
        {
            lDiffuse = mix(lDiffuseInterior, lDiffuse, vec3(interiorExteriorBlend));
            currColor = mix(interiorAmbient, currColor, vec3(interiorExteriorBlend));
        }
        else
        {
            lDiffuse = lDiffuseInterior;
            currColor = interiorAmbient;
        }
    }
    vec3 gammaDiffTerm = matDiffuse * (currColor + lDiffuse);
    vec3 linearDiffTerm = (matDiffuse * matDiffuse) * localDiffuse;
    vec3 specTerm = vec3(0.0);
    vec3 emTerm = vec3(0.0);
    return (sqrt((gammaDiffTerm * gammaDiffTerm) + linearDiffTerm) + specTerm) + emTerm;
}

void main()
{
    vec4 tex = texture2D(uTexture, vTexCoord);
    vec4 tex2 = texture2D(uTexture2, vTexCoord2);
    vec4 tex3 = texture2D(uTexture3, vTexCoord3);
    if (_220.UseLitColor_EnableAlpha_PixelShader.y == 1)
    {
        if ((tex.w - 0.501960813999176025390625) < 0.0)
        {
            discard;
        }
    }
    int uPixelShader = _220.UseLitColor_EnableAlpha_PixelShader.z;
    vec4 finalColor = vec4(0.0, 0.0, 0.0, 1.0);
    vec3 matDiffuse = vec3(0.0);
    vec3 env = vec3(0.0);
    float finalOpacity = 0.0;
    #if (FRAGMENTSHADER == (-1))
    matDiffuse = (tex.xyz * vColor.xyz) + (tex2.xyz * vColor2.zyx);
    finalOpacity = tex.w;
    #endif
    #if (FRAGMENTSHADER == 0)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 1)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 2)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 3)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = tex2.xyz * tex.w;
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 4)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 5)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = (tex.xyz * tex.w) * tex2.xyz;
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 6)
    vec3 layer1 = tex.xyz;
    vec3 layer2 = mix(layer1, tex2.xyz, vec3(tex2.w));
    matDiffuse = (vColor.xyz * 2.0) * mix(layer2, layer1, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 7)
    vec4 colorMix = mix(tex2, tex, vec4(vColor2.w));
    matDiffuse = colorMix.xyz * (vColor.xyz * 2.0);
    env = (colorMix.xyz * colorMix.w) * tex3.xyz;
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 8)
    vec3 layer1_1 = tex.xyz;
    vec3 layer2_1 = tex2.xyz;
    matDiffuse = (vColor.xyz * 2.0) * mix(layer2_1, layer1_1, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 9)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = (tex2.xyz * tex2.w) * vColor2.w;
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 10)
    float mixFactor = clamp(tex3.w * vColor2.w, 0.0, 1.0);
    matDiffuse = (vColor.xyz * 2.0) * mix(mix((tex.xyz * tex2.xyz) * 2.0, tex3.xyz, vec3(mixFactor)), tex.xyz, vec3(tex.w));
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 11)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    env = ((tex.xyz * tex.w) * tex2.xyz) + ((tex3.xyz * tex3.w) * vColor2.w);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 12)
    matDiffuse = (vColor.xyz * 2.0) * mix(tex2.xyz, tex.xyz, vec3(vColor2.w));
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 13)
    vec3 t1diffuse = tex2.xyz * (1.0 - tex2.w);
    matDiffuse = (vColor.xyz * 2.0) * mix(t1diffuse, tex.xyz, vec3(vColor2.w));
    env = (tex2.xyz * tex2.w) * (1.0 - vColor2.w);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 13)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 14)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 15)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 16)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 17)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 18)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    #if (FRAGMENTSHADER == 19)
    matDiffuse = tex.xyz * (vColor.xyz * 2.0);
    finalOpacity = vColor.w;
    #endif
    vec3 param = matDiffuse;
    vec3 param_1 = vNormal;
    bool param_2 = true;
    float param_3 = vPosition.w;
    SceneWideParams param_4;
    param_4.uLookAtMat = _688.scene.uLookAtMat;
    param_4.uPMatrix = _688.scene.uPMatrix;
    param_4.uViewUp = _688.scene.uViewUp;
    param_4.uInteriorSunDir = _688.scene.uInteriorSunDir;
    param_4.extLight.uExteriorAmbientColor = _688.scene.extLight.uExteriorAmbientColor;
    param_4.extLight.uExteriorHorizontAmbientColor = _688.scene.extLight.uExteriorHorizontAmbientColor;
    param_4.extLight.uExteriorGroundAmbientColor = _688.scene.extLight.uExteriorGroundAmbientColor;
    param_4.extLight.uExteriorDirectColor = _688.scene.extLight.uExteriorDirectColor;
    param_4.extLight.uExteriorDirectColorDir = _688.scene.extLight.uExteriorDirectColorDir;
    InteriorLightParam param_5;
    param_5.uInteriorAmbientColorAndApplyInteriorLight = _692.intLight.uInteriorAmbientColorAndApplyInteriorLight;
    param_5.uInteriorDirectColorAndApplyExteriorLight = _692.intLight.uInteriorDirectColorAndApplyExteriorLight;
    vec3 param_6 = vec3(0.0);
    finalColor = vec4(calcLight(param, param_1, param_2, param_3, param_4, param_5, param_6, vColor2.xyz), finalOpacity);
    if (finalColor.w < _220.FogColor_AlphaTest.w)
    {
        discard;
    }
    finalColor.w = 1.0;
    gl_FragData[0] = finalColor;
}


#version 100

struct SceneExteriorLight
{
    vec4 uExteriorAmbientColor;
    vec4 uExteriorHorizontAmbientColor;
    vec4 uExteriorGroundAmbientColor;
    vec4 uExteriorDirectColor;
    vec4 uExteriorDirectColorDir;
};

struct SceneWideParams
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
    vec4 uViewUp;
    vec4 uInteriorSunDir;
    SceneExteriorLight extLight;
};

struct sceneWideBlockVSPS
{
    SceneWideParams scene;
};

uniform sceneWideBlockVSPS _27;

attribute vec4 aPositionTransp;
varying vec2 vTextCoords;
varying vec3 vPosition;
attribute vec2 aTexCoord;

void main()
{
    vec4 aPositionVec4 = vec4(aPositionTransp.xyz, 1.0);
    mat4 cameraMatrix = _27.scene.uLookAtMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    vTextCoords = aPositionVec4.xy / vec2(33.333332061767578125);
    gl_Position = _27.scene.uPMatrix * cameraPoint;
    vPosition = cameraPoint.xyz;
}


#version 100

struct sceneWideBlockVSPS
{
    mat4 uLookAtMat;
    mat4 uPMatrix;
};

uniform sceneWideBlockVSPS _24;

struct modelWideBlockVS
{
    mat4 uPlacementMat;
};

uniform modelWideBlockVS _32;

attribute vec3 aPosition;
varying vec3 vPosition;

void main()
{
    vec4 aPositionVec4 = vec4(aPosition, 1.0);
    mat4 cameraMatrix = _24.uLookAtMat * _32.uPlacementMat;
    vec4 cameraPoint = cameraMatrix * aPositionVec4;
    gl_Position = _24.uPMatrix * cameraPoint;
    vPosition = cameraPoint.xyz;
}


#version 100

struct meshWideBlockPS
{
    float uWidth;
    float uHeight;
    float uX;
    float uY;
};

uniform meshWideBlockPS _36;

varying vec2 texCoord;
attribute vec2 position;
attribute vec2 _texture;

void main()
{
    texCoord = (position * 0.5) + vec2(0.5);
    gl_Position = vec4((((((position.x + 1.0) / 2.0) * _36.uWidth) + _36.uX) * 2.0) - 1.0, (((((position.y + 1.0) / 2.0) * _36.uHeight) + _36.uY) * 2.0) - 1.0, 0.0, 1.0);
}


#version 100
#ifdef GL_ARB_shading_language_420pack
#extension GL_ARB_shading_language_420pack : require
#endif

uniform sampler2D uTexture;

varying vec2 vTexcoord0;
varying vec4 vColor;

void main()
{
    vec4 tex = texture2D(uTexture, vTexcoord0);
    gl_FragData[0] = vec4(vColor.xyz * tex.xyz, tex.w * vColor.w);
}


