this.onerror = function(e) {
  console.error(e);
}


function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}
function getTotalMemory() {
  return TOTAL_MEMORY;
}
function stringToUTF8(str, outPtr, maxBytesToWrite) {
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) {
      ++len;
    } else if (u <= 0x7FF) {
      len += 2;
    } else if (u <= 0xFFFF) {
      len += 3;
    } else if (u <= 0x1FFFFF) {
      len += 4;
    } else if (u <= 0x3FFFFFF) {
      len += 5;
    } else {
      len += 6;
    }
  }
  return len;
}
function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      outU8Array[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      outU8Array[outIdx++] = 0xC0 | (u >> 6);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      outU8Array[outIdx++] = 0xE0 | (u >> 12);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x1FFFFF) {
      if (outIdx + 3 >= endIdx) break;
      outU8Array[outIdx++] = 0xF0 | (u >> 18);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x3FFFFFF) {
      if (outIdx + 4 >= endIdx) break;
      outU8Array[outIdx++] = 0xF8 | (u >> 24);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 5 >= endIdx) break;
      outU8Array[outIdx++] = 0xFC | (u >> 30);
      outU8Array[outIdx++] = 0x80 | ((u >> 24) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  outU8Array[outIdx] = 0;
  return outIdx - startIdx;
}
function _emscripten_is_main_runtime_thread() {
    return __pthread_is_main_runtime_thread|0; // Semantically the same as testing "!ENVIRONMENT_IS_PTHREAD" outside the asm.js scope
}
function _emscripten_futex_wait(addr, val, timeout) {
      if (addr <= 0 || addr > HEAP8.length || addr&3 != 0) return -22;
  //    dump('futex_wait addr:' + addr + ' by thread: ' + _pthread_self() + (ENVIRONMENT_IS_PTHREAD?'(pthread)':'') + '\n');
      if (ENVIRONMENT_IS_WORKER) {
        var ret = Atomics.wait(HEAP32, addr >> 2, val, timeout);
  //    dump('futex_wait done by thread: ' + _pthread_self() + (ENVIRONMENT_IS_PTHREAD?'(pthread)':'') + '\n');
        if (ret === 'timed-out') return -110;
        if (ret === 'not-equal') return -11;
        if (ret === 'ok') return 0;
        throw 'Atomics.wait returned an unexpected value ' + ret;
      } else {
        // Atomics.wait is not available in the main browser thread, so simulate it via busy spinning.
        var loadedVal = Atomics.load(HEAP32, addr >> 2);
        if (val != loadedVal) return -11;
  
        var tNow = performance.now();
        var tEnd = tNow + timeout;
  
  
        // Register globally which address the main thread is simulating to be waiting on. When zero, main thread is not waiting on anything,
        // and on nonzero, the contents of address pointed by __main_thread_futex_wait_address tell which address the main thread is simulating its wait on.
        Atomics.store(HEAP32, __main_thread_futex_wait_address >> 2, addr);
        var ourWaitAddress = addr; // We may recursively re-enter this function while processing queued calls, in which case we'll do a spurious wakeup of the older wait operation.
        while (addr == ourWaitAddress) {
          tNow = performance.now();
          if (tNow > tEnd) {
            return -110;
          }
          _emscripten_main_thread_process_queued_calls(); // We are performing a blocking loop here, so must pump any pthreads if they want to perform operations that are proxied.
          addr = Atomics.load(HEAP32, __main_thread_futex_wait_address >> 2); // Look for a worker thread waking us up.
        }
        return 0;
      }
    }
function _malloc($0) {
 $0 = $0|0;
 var $$0$i = 0, $$0$i$i = 0, $$0$i$i$i = 0, $$0$i16$i = 0, $$0169$i = 0, $$0170$i = 0, $$0171$i = 0, $$0193 = 0, $$0195 = 0, $$02014$i$i = 0, $$0202$lcssa$i$i = 0, $$02023$i$i = 0, $$0206$i$i = 0, $$0207$i$i = 0, $$024364$i = 0, $$0259$i$i = 0, $$02604$i$i = 0, $$0261$lcssa$i$i = 0, $$02613$i$i = 0, $$0267$i$i = 0;
 var $$0268$i$i = 0, $$0318$i = 0, $$032012$i = 0, $$0321$lcssa$i = 0, $$032111$i = 0, $$0323$i = 0, $$0329$i = 0, $$0335$i = 0, $$0336$i = 0, $$0338$i = 0, $$0339$i = 0, $$0344$i = 0, $$1 = 0, $$1174$i = 0, $$1174$i$be = 0, $$1174$i$ph = 0, $$1176$i = 0, $$1176$i$be = 0, $$1176$i$ph = 0, $$124463$i = 0;
 var $$1263$i$i = 0, $$1263$i$i$be = 0, $$1263$i$i$ph = 0, $$1265$i$i = 0, $$1265$i$i$be = 0, $$1265$i$i$ph = 0, $$1319$i = 0, $$1324$i = 0, $$1340$i = 0, $$1346$i = 0, $$1346$i$be = 0, $$1346$i$ph = 0, $$1350$i = 0, $$1350$i$be = 0, $$1350$i$ph = 0, $$2 = 0, $$2234243136$i = 0, $$2247$ph$i = 0, $$2253$ph$i = 0, $$2331$i = 0;
 var $$3$i = 0, $$3$i$i = 0, $$3$i196 = 0, $$3$i196210 = 0, $$3229$i = 0, $$3235$i = 0, $$3326$i = 0, $$3348$i = 0, $$4$lcssa$i = 0, $$415$i = 0, $$415$i$ph = 0, $$4230$i = 0, $$4236$i = 0, $$4327$lcssa$i = 0, $$432714$i = 0, $$432714$i$ph = 0, $$4333$i = 0, $$533413$i = 0, $$533413$i$ph = 0, $$7$i = 0;
 var $$7239$i = 0, $$pre = 0, $$pre$i = 0, $$pre$i$i = 0, $$pre$i17$i = 0, $$pre$i201 = 0, $$pre$phi$i$iZ2D = 0, $$pre$phi$i18$iZ2D = 0, $$pre$phi$i202Z2D = 0, $$pre$phi$iZ2D = 0, $$pre$phiZ2D = 0, $$sink = 0, $$sink319 = 0, $$sink320 = 0, $1 = 0, $10 = 0, $100 = 0, $1000 = 0, $1001 = 0, $1002 = 0;
 var $1003 = 0, $1004 = 0, $1005 = 0, $1006 = 0, $1007 = 0, $1008 = 0, $1009 = 0, $101 = 0, $1010 = 0, $1011 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0;
 var $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0;
 var $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0;
 var $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0;
 var $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0;
 var $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0;
 var $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0;
 var $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0;
 var $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0;
 var $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0;
 var $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0;
 var $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0;
 var $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0;
 var $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0;
 var $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0;
 var $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0, $38 = 0, $380 = 0, $381 = 0;
 var $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $4 = 0;
 var $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0, $414 = 0, $415 = 0, $416 = 0, $417 = 0;
 var $418 = 0, $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0, $430 = 0, $431 = 0, $432 = 0, $433 = 0, $434 = 0, $435 = 0;
 var $436 = 0, $437 = 0, $438 = 0, $439 = 0, $44 = 0, $440 = 0, $441 = 0, $442 = 0, $443 = 0, $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $45 = 0, $450 = 0, $451 = 0, $452 = 0, $453 = 0;
 var $454 = 0, $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $465 = 0, $466 = 0, $467 = 0, $468 = 0, $469 = 0, $47 = 0, $470 = 0, $471 = 0;
 var $472 = 0, $473 = 0, $474 = 0, $475 = 0, $476 = 0, $477 = 0, $478 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0, $482 = 0, $483 = 0, $484 = 0, $485 = 0, $486 = 0, $487 = 0, $488 = 0, $489 = 0, $49 = 0;
 var $490 = 0, $491 = 0, $492 = 0, $493 = 0, $494 = 0, $495 = 0, $496 = 0, $497 = 0, $498 = 0, $499 = 0, $5 = 0, $50 = 0, $500 = 0, $501 = 0, $502 = 0, $503 = 0, $504 = 0, $505 = 0, $506 = 0, $507 = 0;
 var $508 = 0, $509 = 0, $51 = 0, $510 = 0, $511 = 0, $512 = 0, $513 = 0, $514 = 0, $515 = 0, $516 = 0, $517 = 0, $518 = 0, $519 = 0, $52 = 0, $520 = 0, $521 = 0, $522 = 0, $523 = 0, $524 = 0, $525 = 0;
 var $526 = 0, $527 = 0, $528 = 0, $529 = 0, $53 = 0, $530 = 0, $531 = 0, $532 = 0, $533 = 0, $534 = 0, $535 = 0, $536 = 0, $537 = 0, $538 = 0, $539 = 0, $54 = 0, $540 = 0, $541 = 0, $542 = 0, $543 = 0;
 var $544 = 0, $545 = 0, $546 = 0, $547 = 0, $548 = 0, $549 = 0, $55 = 0, $550 = 0, $551 = 0, $552 = 0, $553 = 0, $554 = 0, $555 = 0, $556 = 0, $557 = 0, $558 = 0, $559 = 0, $56 = 0, $560 = 0, $561 = 0;
 var $562 = 0, $563 = 0, $564 = 0, $565 = 0, $566 = 0, $567 = 0, $568 = 0, $569 = 0, $57 = 0, $570 = 0, $571 = 0, $572 = 0, $573 = 0, $574 = 0, $575 = 0, $576 = 0, $577 = 0, $578 = 0, $579 = 0, $58 = 0;
 var $580 = 0, $581 = 0, $582 = 0, $583 = 0, $584 = 0, $585 = 0, $586 = 0, $587 = 0, $588 = 0, $589 = 0, $59 = 0, $590 = 0, $591 = 0, $592 = 0, $593 = 0, $594 = 0, $595 = 0, $596 = 0, $597 = 0, $598 = 0;
 var $599 = 0, $6 = 0, $60 = 0, $600 = 0, $601 = 0, $602 = 0, $603 = 0, $604 = 0, $605 = 0, $606 = 0, $607 = 0, $608 = 0, $609 = 0, $61 = 0, $610 = 0, $611 = 0, $612 = 0, $613 = 0, $614 = 0, $615 = 0;
 var $616 = 0, $617 = 0, $618 = 0, $619 = 0, $62 = 0, $620 = 0, $621 = 0, $622 = 0, $623 = 0, $624 = 0, $625 = 0, $626 = 0, $627 = 0, $628 = 0, $629 = 0, $63 = 0, $630 = 0, $631 = 0, $632 = 0, $633 = 0;
 var $634 = 0, $635 = 0, $636 = 0, $637 = 0, $638 = 0, $639 = 0, $64 = 0, $640 = 0, $641 = 0, $642 = 0, $643 = 0, $644 = 0, $645 = 0, $646 = 0, $647 = 0, $648 = 0, $649 = 0, $65 = 0, $650 = 0, $651 = 0;
 var $652 = 0, $653 = 0, $654 = 0, $655 = 0, $656 = 0, $657 = 0, $658 = 0, $659 = 0, $66 = 0, $660 = 0, $661 = 0, $662 = 0, $663 = 0, $664 = 0, $665 = 0, $666 = 0, $667 = 0, $668 = 0, $669 = 0, $67 = 0;
 var $670 = 0, $671 = 0, $672 = 0, $673 = 0, $674 = 0, $675 = 0, $676 = 0, $677 = 0, $678 = 0, $679 = 0, $68 = 0, $680 = 0, $681 = 0, $682 = 0, $683 = 0, $684 = 0, $685 = 0, $686 = 0, $687 = 0, $688 = 0;
 var $689 = 0, $69 = 0, $690 = 0, $691 = 0, $692 = 0, $693 = 0, $694 = 0, $695 = 0, $696 = 0, $697 = 0, $698 = 0, $699 = 0, $7 = 0, $70 = 0, $700 = 0, $701 = 0, $702 = 0, $703 = 0, $704 = 0, $705 = 0;
 var $706 = 0, $707 = 0, $708 = 0, $709 = 0, $71 = 0, $710 = 0, $711 = 0, $712 = 0, $713 = 0, $714 = 0, $715 = 0, $716 = 0, $717 = 0, $718 = 0, $719 = 0, $72 = 0, $720 = 0, $721 = 0, $722 = 0, $723 = 0;
 var $724 = 0, $725 = 0, $726 = 0, $727 = 0, $728 = 0, $729 = 0, $73 = 0, $730 = 0, $731 = 0, $732 = 0, $733 = 0, $734 = 0, $735 = 0, $736 = 0, $737 = 0, $738 = 0, $739 = 0, $74 = 0, $740 = 0, $741 = 0;
 var $742 = 0, $743 = 0, $744 = 0, $745 = 0, $746 = 0, $747 = 0, $748 = 0, $749 = 0, $75 = 0, $750 = 0, $751 = 0, $752 = 0, $753 = 0, $754 = 0, $755 = 0, $756 = 0, $757 = 0, $758 = 0, $759 = 0, $76 = 0;
 var $760 = 0, $761 = 0, $762 = 0, $763 = 0, $764 = 0, $765 = 0, $766 = 0, $767 = 0, $768 = 0, $769 = 0, $77 = 0, $770 = 0, $771 = 0, $772 = 0, $773 = 0, $774 = 0, $775 = 0, $776 = 0, $777 = 0, $778 = 0;
 var $779 = 0, $78 = 0, $780 = 0, $781 = 0, $782 = 0, $783 = 0, $784 = 0, $785 = 0, $786 = 0, $787 = 0, $788 = 0, $789 = 0, $79 = 0, $790 = 0, $791 = 0, $792 = 0, $793 = 0, $794 = 0, $795 = 0, $796 = 0;
 var $797 = 0, $798 = 0, $799 = 0, $8 = 0, $80 = 0, $800 = 0, $801 = 0, $802 = 0, $803 = 0, $804 = 0, $805 = 0, $806 = 0, $807 = 0, $808 = 0, $809 = 0, $81 = 0, $810 = 0, $811 = 0, $812 = 0, $813 = 0;
 var $814 = 0, $815 = 0, $816 = 0, $817 = 0, $818 = 0, $819 = 0, $82 = 0, $820 = 0, $821 = 0, $822 = 0, $823 = 0, $824 = 0, $825 = 0, $826 = 0, $827 = 0, $828 = 0, $829 = 0, $83 = 0, $830 = 0, $831 = 0;
 var $832 = 0, $833 = 0, $834 = 0, $835 = 0, $836 = 0, $837 = 0, $838 = 0, $839 = 0, $84 = 0, $840 = 0, $841 = 0, $842 = 0, $843 = 0, $844 = 0, $845 = 0, $846 = 0, $847 = 0, $848 = 0, $849 = 0, $85 = 0;
 var $850 = 0, $851 = 0, $852 = 0, $853 = 0, $854 = 0, $855 = 0, $856 = 0, $857 = 0, $858 = 0, $859 = 0, $86 = 0, $860 = 0, $861 = 0, $862 = 0, $863 = 0, $864 = 0, $865 = 0, $866 = 0, $867 = 0, $868 = 0;
 var $869 = 0, $87 = 0, $870 = 0, $871 = 0, $872 = 0, $873 = 0, $874 = 0, $875 = 0, $876 = 0, $877 = 0, $878 = 0, $879 = 0, $88 = 0, $880 = 0, $881 = 0, $882 = 0, $883 = 0, $884 = 0, $885 = 0, $886 = 0;
 var $887 = 0, $888 = 0, $889 = 0, $89 = 0, $890 = 0, $891 = 0, $892 = 0, $893 = 0, $894 = 0, $895 = 0, $896 = 0, $897 = 0, $898 = 0, $899 = 0, $9 = 0, $90 = 0, $900 = 0, $901 = 0, $902 = 0, $903 = 0;
 var $904 = 0, $905 = 0, $906 = 0, $907 = 0, $908 = 0, $909 = 0, $91 = 0, $910 = 0, $911 = 0, $912 = 0, $913 = 0, $914 = 0, $915 = 0, $916 = 0, $917 = 0, $918 = 0, $919 = 0, $92 = 0, $920 = 0, $921 = 0;
 var $922 = 0, $923 = 0, $924 = 0, $925 = 0, $926 = 0, $927 = 0, $928 = 0, $929 = 0, $93 = 0, $930 = 0, $931 = 0, $932 = 0, $933 = 0, $934 = 0, $935 = 0, $936 = 0, $937 = 0, $938 = 0, $939 = 0, $94 = 0;
 var $940 = 0, $941 = 0, $942 = 0, $943 = 0, $944 = 0, $945 = 0, $946 = 0, $947 = 0, $948 = 0, $949 = 0, $95 = 0, $950 = 0, $951 = 0, $952 = 0, $953 = 0, $954 = 0, $955 = 0, $956 = 0, $957 = 0, $958 = 0;
 var $959 = 0, $96 = 0, $960 = 0, $961 = 0, $962 = 0, $963 = 0, $964 = 0, $965 = 0, $966 = 0, $967 = 0, $968 = 0, $969 = 0, $97 = 0, $970 = 0, $971 = 0, $972 = 0, $973 = 0, $974 = 0, $975 = 0, $976 = 0;
 var $977 = 0, $978 = 0, $979 = 0, $98 = 0, $980 = 0, $981 = 0, $982 = 0, $983 = 0, $984 = 0, $985 = 0, $986 = 0, $987 = 0, $988 = 0, $989 = 0, $99 = 0, $990 = 0, $991 = 0, $992 = 0, $993 = 0, $994 = 0;
 var $995 = 0, $996 = 0, $997 = 0, $998 = 0, $999 = 0, $cond$i = 0, $cond$i$i = 0, $cond$i200 = 0, $or$cond$i = 0, $or$cond$i205 = 0, $or$cond1$i = 0, $or$cond1$i203 = 0, $or$cond11$i = 0, $or$cond2$i = 0, $or$cond43$i = 0, $or$cond5$i = 0, $or$cond6$i = 0, $or$cond7$i = 0, $or$cond8$i = 0, $or$cond9$i = 0;
 var $spec$select$i = 0, $spec$select$i198 = 0, $spec$select1$i = 0, $spec$select10$i = 0, $spec$select2$i = 0, $spec$select4$i = 0, $spec$select42$i = 0, $spec$select9$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0; if ((STACKTOP|0) >= (STACK_MAX|0)) abortStackOverflow(16|0);
 $1 = sp + 12|0;
 $2 = sp + 8|0;
 $3 = sp + 4|0;
 $4 = sp;
 $5 = HEAP32[13780]|0;
 $6 = ($5|0)==(0);
 if ($6) {
  (___pthread_mutex_lock(55144)|0);
  $7 = HEAP32[13780]|0;
  $8 = ($7|0)==(0);
  if ($8) {
   HEAP32[(55128)>>2] = 4096;
   HEAP32[(55124)>>2] = 4096;
   HEAP32[(55132)>>2] = -1;
   HEAP32[(55136)>>2] = -1;
   HEAP32[(55140)>>2] = 2;
   HEAP32[(55616)>>2] = 2;
   $9 = (_pthread_mutexattr_init($3)|0);
   $10 = ($9|0)==(0);
   if ($10) {
    $11 = (_pthread_mutex_init((55620),$3)|0);
    $12 = ($11|0)==(0);
    if ($12) {
    }
   }
   $13 = $4;
   $14 = $13 & -16;
   $15 = $14 ^ 1431655768;
   Atomics_store(HEAP32,13780,$15)|0;
  }
  (___pthread_mutex_unlock(55144)|0);
 }
 $16 = HEAP32[(55616)>>2]|0;
 $17 = $16 & 2;
 $18 = ($17|0)==(0);
 if (!($18)) {
  $19 = (___pthread_mutex_lock((55620))|0);
  $20 = ($19|0)==(0);
  if (!($20)) {
   $$1 = 0;
   STACKTOP = sp;return ($$1|0);
  }
 }
 $21 = ($0>>>0)<(245);
 do {
  if ($21) {
   $22 = ($0>>>0)<(11);
   $23 = (($0) + 11)|0;
   $24 = $23 & -8;
   $25 = $22 ? 16 : $24;
   $26 = $25 >>> 3;
   $27 = HEAP32[13793]|0;
   $28 = $27 >>> $26;
   $29 = $28 & 3;
   $30 = ($29|0)==(0);
   if (!($30)) {
    $31 = $28 & 1;
    $32 = $31 ^ 1;
    $33 = (($32) + ($26))|0;
    $34 = $33 << 1;
    $35 = (55212 + ($34<<2)|0);
    $36 = ((($35)) + 8|0);
    $37 = HEAP32[$36>>2]|0;
    $38 = ((($37)) + 8|0);
    $39 = HEAP32[$38>>2]|0;
    $40 = ($39|0)==($35|0);
    if ($40) {
     $41 = 1 << $33;
     $42 = $41 ^ -1;
     $43 = $27 & $42;
     HEAP32[13793] = $43;
    } else {
     $44 = ((($39)) + 12|0);
     HEAP32[$44>>2] = $35;
     HEAP32[$36>>2] = $39;
    }
    $45 = $33 << 3;
    $46 = $45 | 3;
    $47 = ((($37)) + 4|0);
    HEAP32[$47>>2] = $46;
    $48 = (($37) + ($45)|0);
    $49 = ((($48)) + 4|0);
    $50 = HEAP32[$49>>2]|0;
    $51 = $50 | 1;
    HEAP32[$49>>2] = $51;
    $$2 = $38;
    break;
   }
   $52 = HEAP32[(55180)>>2]|0;
   $53 = ($25>>>0)>($52>>>0);
   if ($53) {
    $54 = ($28|0)==(0);
    if (!($54)) {
     $55 = $28 << $26;
     $56 = 2 << $26;
     $57 = (0 - ($56))|0;
     $58 = $56 | $57;
     $59 = $55 & $58;
     $60 = (0 - ($59))|0;
     $61 = $59 & $60;
     $62 = (($61) + -1)|0;
     $63 = $62 >>> 12;
     $64 = $63 & 16;
     $65 = $62 >>> $64;
     $66 = $65 >>> 5;
     $67 = $66 & 8;
     $68 = $67 | $64;
     $69 = $65 >>> $67;
     $70 = $69 >>> 2;
     $71 = $70 & 4;
     $72 = $68 | $71;
     $73 = $69 >>> $71;
     $74 = $73 >>> 1;
     $75 = $74 & 2;
     $76 = $72 | $75;
     $77 = $73 >>> $75;
     $78 = $77 >>> 1;
     $79 = $78 & 1;
     $80 = $76 | $79;
     $81 = $77 >>> $79;
     $82 = (($80) + ($81))|0;
     $83 = $82 << 1;
     $84 = (55212 + ($83<<2)|0);
     $85 = ((($84)) + 8|0);
     $86 = HEAP32[$85>>2]|0;
     $87 = ((($86)) + 8|0);
     $88 = HEAP32[$87>>2]|0;
     $89 = ($88|0)==($84|0);
     if ($89) {
      $90 = 1 << $82;
      $91 = $90 ^ -1;
      $92 = $27 & $91;
      HEAP32[13793] = $92;
      $109 = $92;
     } else {
      $93 = ((($88)) + 12|0);
      HEAP32[$93>>2] = $84;
      HEAP32[$85>>2] = $88;
      $109 = $27;
     }
     $94 = $82 << 3;
     $95 = (($94) - ($25))|0;
     $96 = $25 | 3;
     $97 = ((($86)) + 4|0);
     HEAP32[$97>>2] = $96;
     $98 = (($86) + ($25)|0);
     $99 = $95 | 1;
     $100 = ((($98)) + 4|0);
     HEAP32[$100>>2] = $99;
     $101 = (($86) + ($94)|0);
     HEAP32[$101>>2] = $95;
     $102 = ($52|0)==(0);
     if (!($102)) {
      $103 = HEAP32[(55192)>>2]|0;
      $104 = $52 >>> 3;
      $105 = $104 << 1;
      $106 = (55212 + ($105<<2)|0);
      $107 = 1 << $104;
      $108 = $109 & $107;
      $110 = ($108|0)==(0);
      if ($110) {
       $111 = $109 | $107;
       HEAP32[13793] = $111;
       $$pre = ((($106)) + 8|0);
       $$0195 = $106;$$pre$phiZ2D = $$pre;
      } else {
       $112 = ((($106)) + 8|0);
       $113 = HEAP32[$112>>2]|0;
       $$0195 = $113;$$pre$phiZ2D = $112;
      }
      HEAP32[$$pre$phiZ2D>>2] = $103;
      $114 = ((($$0195)) + 12|0);
      HEAP32[$114>>2] = $103;
      $115 = ((($103)) + 8|0);
      HEAP32[$115>>2] = $$0195;
      $116 = ((($103)) + 12|0);
      HEAP32[$116>>2] = $106;
     }
     HEAP32[(55180)>>2] = $95;
     HEAP32[(55192)>>2] = $98;
     $$2 = $87;
     break;
    }
    $117 = HEAP32[(55176)>>2]|0;
    $118 = ($117|0)==(0);
    if ($118) {
     $$0193 = $25;
     label = 118;
    } else {
     $119 = (0 - ($117))|0;
     $120 = $117 & $119;
     $121 = (($120) + -1)|0;
     $122 = $121 >>> 12;
     $123 = $122 & 16;
     $124 = $121 >>> $123;
     $125 = $124 >>> 5;
     $126 = $125 & 8;
     $127 = $126 | $123;
     $128 = $124 >>> $126;
     $129 = $128 >>> 2;
     $130 = $129 & 4;
     $131 = $127 | $130;
     $132 = $128 >>> $130;
     $133 = $132 >>> 1;
     $134 = $133 & 2;
     $135 = $131 | $134;
     $136 = $132 >>> $134;
     $137 = $136 >>> 1;
     $138 = $137 & 1;
     $139 = $135 | $138;
     $140 = $136 >>> $138;
     $141 = (($139) + ($140))|0;
     $142 = (55476 + ($141<<2)|0);
     $143 = HEAP32[$142>>2]|0;
     $144 = ((($143)) + 4|0);
     $145 = HEAP32[$144>>2]|0;
     $146 = $145 & -8;
     $147 = (($146) - ($25))|0;
     $$0169$i = $143;$$0170$i = $143;$$0171$i = $147;
     while(1) {
      $148 = ((($$0169$i)) + 16|0);
      $149 = HEAP32[$148>>2]|0;
      $150 = ($149|0)==(0|0);
      if ($150) {
       $151 = ((($$0169$i)) + 20|0);
       $152 = HEAP32[$151>>2]|0;
       $153 = ($152|0)==(0|0);
       if ($153) {
        break;
       } else {
        $155 = $152;
       }
      } else {
       $155 = $149;
      }
      $154 = ((($155)) + 4|0);
      $156 = HEAP32[$154>>2]|0;
      $157 = $156 & -8;
      $158 = (($157) - ($25))|0;
      $159 = ($158>>>0)<($$0171$i>>>0);
      $spec$select$i = $159 ? $158 : $$0171$i;
      $spec$select1$i = $159 ? $155 : $$0170$i;
      $$0169$i = $155;$$0170$i = $spec$select1$i;$$0171$i = $spec$select$i;
     }
     $160 = (($$0170$i) + ($25)|0);
     $161 = ($160>>>0)>($$0170$i>>>0);
     if ($161) {
      $162 = ((($$0170$i)) + 24|0);
      $163 = HEAP32[$162>>2]|0;
      $164 = ((($$0170$i)) + 12|0);
      $165 = HEAP32[$164>>2]|0;
      $166 = ($165|0)==($$0170$i|0);
      do {
       if ($166) {
        $171 = ((($$0170$i)) + 20|0);
        $172 = HEAP32[$171>>2]|0;
        $173 = ($172|0)==(0|0);
        if ($173) {
         $174 = ((($$0170$i)) + 16|0);
         $175 = HEAP32[$174>>2]|0;
         $176 = ($175|0)==(0|0);
         if ($176) {
          $$3$i = 0;
          break;
         } else {
          $$1174$i$ph = $175;$$1176$i$ph = $174;
         }
        } else {
         $$1174$i$ph = $172;$$1176$i$ph = $171;
        }
        $$1174$i = $$1174$i$ph;$$1176$i = $$1176$i$ph;
        while(1) {
         $177 = ((($$1174$i)) + 20|0);
         $178 = HEAP32[$177>>2]|0;
         $179 = ($178|0)==(0|0);
         if ($179) {
          $180 = ((($$1174$i)) + 16|0);
          $181 = HEAP32[$180>>2]|0;
          $182 = ($181|0)==(0|0);
          if ($182) {
           break;
          } else {
           $$1174$i$be = $181;$$1176$i$be = $180;
          }
         } else {
          $$1174$i$be = $178;$$1176$i$be = $177;
         }
         $$1174$i = $$1174$i$be;$$1176$i = $$1176$i$be;
        }
        HEAP32[$$1176$i>>2] = 0;
        $$3$i = $$1174$i;
       } else {
        $167 = ((($$0170$i)) + 8|0);
        $168 = HEAP32[$167>>2]|0;
        $169 = ((($168)) + 12|0);
        HEAP32[$169>>2] = $165;
        $170 = ((($165)) + 8|0);
        HEAP32[$170>>2] = $168;
        $$3$i = $165;
       }
      } while(0);
      $183 = ($163|0)==(0|0);
      do {
       if (!($183)) {
        $184 = ((($$0170$i)) + 28|0);
        $185 = HEAP32[$184>>2]|0;
        $186 = (55476 + ($185<<2)|0);
        $187 = HEAP32[$186>>2]|0;
        $188 = ($$0170$i|0)==($187|0);
        if ($188) {
         HEAP32[$186>>2] = $$3$i;
         $cond$i = ($$3$i|0)==(0|0);
         if ($cond$i) {
          $189 = 1 << $185;
          $190 = $189 ^ -1;
          $191 = $117 & $190;
          HEAP32[(55176)>>2] = $191;
          break;
         }
        } else {
         $192 = ((($163)) + 16|0);
         $193 = HEAP32[$192>>2]|0;
         $194 = ($193|0)==($$0170$i|0);
         $195 = ((($163)) + 20|0);
         $$sink = $194 ? $192 : $195;
         HEAP32[$$sink>>2] = $$3$i;
         $196 = ($$3$i|0)==(0|0);
         if ($196) {
          break;
         }
        }
        $197 = ((($$3$i)) + 24|0);
        HEAP32[$197>>2] = $163;
        $198 = ((($$0170$i)) + 16|0);
        $199 = HEAP32[$198>>2]|0;
        $200 = ($199|0)==(0|0);
        if (!($200)) {
         $201 = ((($$3$i)) + 16|0);
         HEAP32[$201>>2] = $199;
         $202 = ((($199)) + 24|0);
         HEAP32[$202>>2] = $$3$i;
        }
        $203 = ((($$0170$i)) + 20|0);
        $204 = HEAP32[$203>>2]|0;
        $205 = ($204|0)==(0|0);
        if (!($205)) {
         $206 = ((($$3$i)) + 20|0);
         HEAP32[$206>>2] = $204;
         $207 = ((($204)) + 24|0);
         HEAP32[$207>>2] = $$3$i;
        }
       }
      } while(0);
      $208 = ($$0171$i>>>0)<(16);
      if ($208) {
       $209 = (($$0171$i) + ($25))|0;
       $210 = $209 | 3;
       $211 = ((($$0170$i)) + 4|0);
       HEAP32[$211>>2] = $210;
       $212 = (($$0170$i) + ($209)|0);
       $213 = ((($212)) + 4|0);
       $214 = HEAP32[$213>>2]|0;
       $215 = $214 | 1;
       HEAP32[$213>>2] = $215;
      } else {
       $216 = $25 | 3;
       $217 = ((($$0170$i)) + 4|0);
       HEAP32[$217>>2] = $216;
       $218 = $$0171$i | 1;
       $219 = ((($160)) + 4|0);
       HEAP32[$219>>2] = $218;
       $220 = (($160) + ($$0171$i)|0);
       HEAP32[$220>>2] = $$0171$i;
       $221 = ($52|0)==(0);
       if (!($221)) {
        $222 = HEAP32[(55192)>>2]|0;
        $223 = $52 >>> 3;
        $224 = $223 << 1;
        $225 = (55212 + ($224<<2)|0);
        $226 = 1 << $223;
        $227 = $226 & $27;
        $228 = ($227|0)==(0);
        if ($228) {
         $229 = $226 | $27;
         HEAP32[13793] = $229;
         $$pre$i = ((($225)) + 8|0);
         $$0$i = $225;$$pre$phi$iZ2D = $$pre$i;
        } else {
         $230 = ((($225)) + 8|0);
         $231 = HEAP32[$230>>2]|0;
         $$0$i = $231;$$pre$phi$iZ2D = $230;
        }
        HEAP32[$$pre$phi$iZ2D>>2] = $222;
        $232 = ((($$0$i)) + 12|0);
        HEAP32[$232>>2] = $222;
        $233 = ((($222)) + 8|0);
        HEAP32[$233>>2] = $$0$i;
        $234 = ((($222)) + 12|0);
        HEAP32[$234>>2] = $225;
       }
       HEAP32[(55180)>>2] = $$0171$i;
       HEAP32[(55192)>>2] = $160;
      }
      $235 = ((($$0170$i)) + 8|0);
      $$2 = $235;
     } else {
      $$0193 = $25;
      label = 118;
     }
    }
   } else {
    $$0193 = $25;
    label = 118;
   }
  } else {
   $236 = ($0>>>0)>(4294967231);
   if ($236) {
    $$0193 = -1;
    label = 118;
   } else {
    $237 = (($0) + 11)|0;
    $238 = $237 & -8;
    $239 = HEAP32[(55176)>>2]|0;
    $240 = ($239|0)==(0);
    if ($240) {
     $$0193 = $238;
     label = 118;
    } else {
     $241 = (0 - ($238))|0;
     $242 = $237 >>> 8;
     $243 = ($242|0)==(0);
     if ($243) {
      $$0335$i = 0;
     } else {
      $244 = ($238>>>0)>(16777215);
      if ($244) {
       $$0335$i = 31;
      } else {
       $245 = (($242) + 1048320)|0;
       $246 = $245 >>> 16;
       $247 = $246 & 8;
       $248 = $242 << $247;
       $249 = (($248) + 520192)|0;
       $250 = $249 >>> 16;
       $251 = $250 & 4;
       $252 = $251 | $247;
       $253 = $248 << $251;
       $254 = (($253) + 245760)|0;
       $255 = $254 >>> 16;
       $256 = $255 & 2;
       $257 = $252 | $256;
       $258 = (14 - ($257))|0;
       $259 = $253 << $256;
       $260 = $259 >>> 15;
       $261 = (($258) + ($260))|0;
       $262 = $261 << 1;
       $263 = (($261) + 7)|0;
       $264 = $238 >>> $263;
       $265 = $264 & 1;
       $266 = $265 | $262;
       $$0335$i = $266;
      }
     }
     $267 = (55476 + ($$0335$i<<2)|0);
     $268 = HEAP32[$267>>2]|0;
     $269 = ($268|0)==(0|0);
     L90: do {
      if ($269) {
       $$2331$i = 0;$$3$i196 = 0;$$3326$i = $241;
       label = 70;
      } else {
       $270 = ($$0335$i|0)==(31);
       $271 = $$0335$i >>> 1;
       $272 = (25 - ($271))|0;
       $273 = $270 ? 0 : $272;
       $274 = $238 << $273;
       $$0318$i = 0;$$0323$i = $241;$$0329$i = $268;$$0336$i = $274;$$0339$i = 0;
       while(1) {
        $275 = ((($$0329$i)) + 4|0);
        $276 = HEAP32[$275>>2]|0;
        $277 = $276 & -8;
        $278 = (($277) - ($238))|0;
        $279 = ($278>>>0)<($$0323$i>>>0);
        if ($279) {
         $280 = ($278|0)==(0);
         if ($280) {
          $$415$i$ph = $$0329$i;$$432714$i$ph = 0;$$533413$i$ph = $$0329$i;
          label = 74;
          break L90;
         } else {
          $$1319$i = $$0329$i;$$1324$i = $278;
         }
        } else {
         $$1319$i = $$0318$i;$$1324$i = $$0323$i;
        }
        $281 = ((($$0329$i)) + 20|0);
        $282 = HEAP32[$281>>2]|0;
        $283 = $$0336$i >>> 31;
        $284 = (((($$0329$i)) + 16|0) + ($283<<2)|0);
        $285 = HEAP32[$284>>2]|0;
        $286 = ($282|0)==(0|0);
        $287 = ($282|0)==($285|0);
        $or$cond1$i = $286 | $287;
        $$1340$i = $or$cond1$i ? $$0339$i : $282;
        $288 = ($285|0)==(0|0);
        $spec$select4$i = $$0336$i << 1;
        if ($288) {
         $$2331$i = $$1340$i;$$3$i196 = $$1319$i;$$3326$i = $$1324$i;
         label = 70;
         break;
        } else {
         $$0318$i = $$1319$i;$$0323$i = $$1324$i;$$0329$i = $285;$$0336$i = $spec$select4$i;$$0339$i = $$1340$i;
        }
       }
      }
     } while(0);
     if ((label|0) == 70) {
      $289 = ($$2331$i|0)==(0|0);
      $290 = ($$3$i196|0)==(0|0);
      $or$cond$i = $289 & $290;
      if ($or$cond$i) {
       $291 = 2 << $$0335$i;
       $292 = (0 - ($291))|0;
       $293 = $291 | $292;
       $294 = $293 & $239;
       $295 = ($294|0)==(0);
       if ($295) {
        $$0193 = $238;
        label = 118;
        break;
       }
       $296 = (0 - ($294))|0;
       $297 = $294 & $296;
       $298 = (($297) + -1)|0;
       $299 = $298 >>> 12;
       $300 = $299 & 16;
       $301 = $298 >>> $300;
       $302 = $301 >>> 5;
       $303 = $302 & 8;
       $304 = $303 | $300;
       $305 = $301 >>> $303;
       $306 = $305 >>> 2;
       $307 = $306 & 4;
       $308 = $304 | $307;
       $309 = $305 >>> $307;
       $310 = $309 >>> 1;
       $311 = $310 & 2;
       $312 = $308 | $311;
       $313 = $309 >>> $311;
       $314 = $313 >>> 1;
       $315 = $314 & 1;
       $316 = $312 | $315;
       $317 = $313 >>> $315;
       $318 = (($316) + ($317))|0;
       $319 = (55476 + ($318<<2)|0);
       $320 = HEAP32[$319>>2]|0;
       $$3$i196210 = 0;$$4333$i = $320;
      } else {
       $$3$i196210 = $$3$i196;$$4333$i = $$2331$i;
      }
      $321 = ($$4333$i|0)==(0|0);
      if ($321) {
       $$4$lcssa$i = $$3$i196210;$$4327$lcssa$i = $$3326$i;
      } else {
       $$415$i$ph = $$3$i196210;$$432714$i$ph = $$3326$i;$$533413$i$ph = $$4333$i;
       label = 74;
      }
     }
     if ((label|0) == 74) {
      $$415$i = $$415$i$ph;$$432714$i = $$432714$i$ph;$$533413$i = $$533413$i$ph;
      while(1) {
       $322 = ((($$533413$i)) + 4|0);
       $323 = HEAP32[$322>>2]|0;
       $324 = $323 & -8;
       $325 = (($324) - ($238))|0;
       $326 = ($325>>>0)<($$432714$i>>>0);
       $spec$select$i198 = $326 ? $325 : $$432714$i;
       $spec$select2$i = $326 ? $$533413$i : $$415$i;
       $327 = ((($$533413$i)) + 16|0);
       $328 = HEAP32[$327>>2]|0;
       $329 = ($328|0)==(0|0);
       if ($329) {
        $330 = ((($$533413$i)) + 20|0);
        $331 = HEAP32[$330>>2]|0;
        $332 = $331;
       } else {
        $332 = $328;
       }
       $333 = ($332|0)==(0|0);
       if ($333) {
        $$4$lcssa$i = $spec$select2$i;$$4327$lcssa$i = $spec$select$i198;
        break;
       } else {
        $$415$i = $spec$select2$i;$$432714$i = $spec$select$i198;$$533413$i = $332;
       }
      }
     }
     $334 = ($$4$lcssa$i|0)==(0|0);
     if ($334) {
      $$0193 = $238;
      label = 118;
     } else {
      $335 = HEAP32[(55180)>>2]|0;
      $336 = (($335) - ($238))|0;
      $337 = ($$4327$lcssa$i>>>0)<($336>>>0);
      if ($337) {
       $338 = (($$4$lcssa$i) + ($238)|0);
       $339 = ($338>>>0)>($$4$lcssa$i>>>0);
       if ($339) {
        $340 = ((($$4$lcssa$i)) + 24|0);
        $341 = HEAP32[$340>>2]|0;
        $342 = ((($$4$lcssa$i)) + 12|0);
        $343 = HEAP32[$342>>2]|0;
        $344 = ($343|0)==($$4$lcssa$i|0);
        do {
         if ($344) {
          $349 = ((($$4$lcssa$i)) + 20|0);
          $350 = HEAP32[$349>>2]|0;
          $351 = ($350|0)==(0|0);
          if ($351) {
           $352 = ((($$4$lcssa$i)) + 16|0);
           $353 = HEAP32[$352>>2]|0;
           $354 = ($353|0)==(0|0);
           if ($354) {
            $$3348$i = 0;
            break;
           } else {
            $$1346$i$ph = $353;$$1350$i$ph = $352;
           }
          } else {
           $$1346$i$ph = $350;$$1350$i$ph = $349;
          }
          $$1346$i = $$1346$i$ph;$$1350$i = $$1350$i$ph;
          while(1) {
           $355 = ((($$1346$i)) + 20|0);
           $356 = HEAP32[$355>>2]|0;
           $357 = ($356|0)==(0|0);
           if ($357) {
            $358 = ((($$1346$i)) + 16|0);
            $359 = HEAP32[$358>>2]|0;
            $360 = ($359|0)==(0|0);
            if ($360) {
             break;
            } else {
             $$1346$i$be = $359;$$1350$i$be = $358;
            }
           } else {
            $$1346$i$be = $356;$$1350$i$be = $355;
           }
           $$1346$i = $$1346$i$be;$$1350$i = $$1350$i$be;
          }
          HEAP32[$$1350$i>>2] = 0;
          $$3348$i = $$1346$i;
         } else {
          $345 = ((($$4$lcssa$i)) + 8|0);
          $346 = HEAP32[$345>>2]|0;
          $347 = ((($346)) + 12|0);
          HEAP32[$347>>2] = $343;
          $348 = ((($343)) + 8|0);
          HEAP32[$348>>2] = $346;
          $$3348$i = $343;
         }
        } while(0);
        $361 = ($341|0)==(0|0);
        do {
         if ($361) {
          $444 = $239;
         } else {
          $362 = ((($$4$lcssa$i)) + 28|0);
          $363 = HEAP32[$362>>2]|0;
          $364 = (55476 + ($363<<2)|0);
          $365 = HEAP32[$364>>2]|0;
          $366 = ($$4$lcssa$i|0)==($365|0);
          if ($366) {
           HEAP32[$364>>2] = $$3348$i;
           $cond$i200 = ($$3348$i|0)==(0|0);
           if ($cond$i200) {
            $367 = 1 << $363;
            $368 = $367 ^ -1;
            $369 = $239 & $368;
            HEAP32[(55176)>>2] = $369;
            $444 = $369;
            break;
           }
          } else {
           $370 = ((($341)) + 16|0);
           $371 = HEAP32[$370>>2]|0;
           $372 = ($371|0)==($$4$lcssa$i|0);
           $373 = ((($341)) + 20|0);
           $$sink319 = $372 ? $370 : $373;
           HEAP32[$$sink319>>2] = $$3348$i;
           $374 = ($$3348$i|0)==(0|0);
           if ($374) {
            $444 = $239;
            break;
           }
          }
          $375 = ((($$3348$i)) + 24|0);
          HEAP32[$375>>2] = $341;
          $376 = ((($$4$lcssa$i)) + 16|0);
          $377 = HEAP32[$376>>2]|0;
          $378 = ($377|0)==(0|0);
          if (!($378)) {
           $379 = ((($$3348$i)) + 16|0);
           HEAP32[$379>>2] = $377;
           $380 = ((($377)) + 24|0);
           HEAP32[$380>>2] = $$3348$i;
          }
          $381 = ((($$4$lcssa$i)) + 20|0);
          $382 = HEAP32[$381>>2]|0;
          $383 = ($382|0)==(0|0);
          if ($383) {
           $444 = $239;
          } else {
           $384 = ((($$3348$i)) + 20|0);
           HEAP32[$384>>2] = $382;
           $385 = ((($382)) + 24|0);
           HEAP32[$385>>2] = $$3348$i;
           $444 = $239;
          }
         }
        } while(0);
        $386 = ($$4327$lcssa$i>>>0)<(16);
        L139: do {
         if ($386) {
          $387 = (($$4327$lcssa$i) + ($238))|0;
          $388 = $387 | 3;
          $389 = ((($$4$lcssa$i)) + 4|0);
          HEAP32[$389>>2] = $388;
          $390 = (($$4$lcssa$i) + ($387)|0);
          $391 = ((($390)) + 4|0);
          $392 = HEAP32[$391>>2]|0;
          $393 = $392 | 1;
          HEAP32[$391>>2] = $393;
         } else {
          $394 = $238 | 3;
          $395 = ((($$4$lcssa$i)) + 4|0);
          HEAP32[$395>>2] = $394;
          $396 = $$4327$lcssa$i | 1;
          $397 = ((($338)) + 4|0);
          HEAP32[$397>>2] = $396;
          $398 = (($338) + ($$4327$lcssa$i)|0);
          HEAP32[$398>>2] = $$4327$lcssa$i;
          $399 = $$4327$lcssa$i >>> 3;
          $400 = ($$4327$lcssa$i>>>0)<(256);
          if ($400) {
           $401 = $399 << 1;
           $402 = (55212 + ($401<<2)|0);
           $403 = HEAP32[13793]|0;
           $404 = 1 << $399;
           $405 = $403 & $404;
           $406 = ($405|0)==(0);
           if ($406) {
            $407 = $403 | $404;
            HEAP32[13793] = $407;
            $$pre$i201 = ((($402)) + 8|0);
            $$0344$i = $402;$$pre$phi$i202Z2D = $$pre$i201;
           } else {
            $408 = ((($402)) + 8|0);
            $409 = HEAP32[$408>>2]|0;
            $$0344$i = $409;$$pre$phi$i202Z2D = $408;
           }
           HEAP32[$$pre$phi$i202Z2D>>2] = $338;
           $410 = ((($$0344$i)) + 12|0);
           HEAP32[$410>>2] = $338;
           $411 = ((($338)) + 8|0);
           HEAP32[$411>>2] = $$0344$i;
           $412 = ((($338)) + 12|0);
           HEAP32[$412>>2] = $402;
           break;
          }
          $413 = $$4327$lcssa$i >>> 8;
          $414 = ($413|0)==(0);
          if ($414) {
           $$0338$i = 0;
          } else {
           $415 = ($$4327$lcssa$i>>>0)>(16777215);
           if ($415) {
            $$0338$i = 31;
           } else {
            $416 = (($413) + 1048320)|0;
            $417 = $416 >>> 16;
            $418 = $417 & 8;
            $419 = $413 << $418;
            $420 = (($419) + 520192)|0;
            $421 = $420 >>> 16;
            $422 = $421 & 4;
            $423 = $422 | $418;
            $424 = $419 << $422;
            $425 = (($424) + 245760)|0;
            $426 = $425 >>> 16;
            $427 = $426 & 2;
            $428 = $423 | $427;
            $429 = (14 - ($428))|0;
            $430 = $424 << $427;
            $431 = $430 >>> 15;
            $432 = (($429) + ($431))|0;
            $433 = $432 << 1;
            $434 = (($432) + 7)|0;
            $435 = $$4327$lcssa$i >>> $434;
            $436 = $435 & 1;
            $437 = $436 | $433;
            $$0338$i = $437;
           }
          }
          $438 = (55476 + ($$0338$i<<2)|0);
          $439 = ((($338)) + 28|0);
          HEAP32[$439>>2] = $$0338$i;
          $440 = ((($338)) + 16|0);
          $441 = ((($440)) + 4|0);
          HEAP32[$441>>2] = 0;
          HEAP32[$440>>2] = 0;
          $442 = 1 << $$0338$i;
          $443 = $444 & $442;
          $445 = ($443|0)==(0);
          if ($445) {
           $446 = $444 | $442;
           HEAP32[(55176)>>2] = $446;
           HEAP32[$438>>2] = $338;
           $447 = ((($338)) + 24|0);
           HEAP32[$447>>2] = $438;
           $448 = ((($338)) + 12|0);
           HEAP32[$448>>2] = $338;
           $449 = ((($338)) + 8|0);
           HEAP32[$449>>2] = $338;
           break;
          }
          $450 = HEAP32[$438>>2]|0;
          $451 = ((($450)) + 4|0);
          $452 = HEAP32[$451>>2]|0;
          $453 = $452 & -8;
          $454 = ($453|0)==($$4327$lcssa$i|0);
          L156: do {
           if ($454) {
            $$0321$lcssa$i = $450;
           } else {
            $455 = ($$0338$i|0)==(31);
            $456 = $$0338$i >>> 1;
            $457 = (25 - ($456))|0;
            $458 = $455 ? 0 : $457;
            $459 = $$4327$lcssa$i << $458;
            $$032012$i = $459;$$032111$i = $450;
            while(1) {
             $466 = $$032012$i >>> 31;
             $467 = (((($$032111$i)) + 16|0) + ($466<<2)|0);
             $462 = HEAP32[$467>>2]|0;
             $468 = ($462|0)==(0|0);
             if ($468) {
              break;
             }
             $460 = $$032012$i << 1;
             $461 = ((($462)) + 4|0);
             $463 = HEAP32[$461>>2]|0;
             $464 = $463 & -8;
             $465 = ($464|0)==($$4327$lcssa$i|0);
             if ($465) {
              $$0321$lcssa$i = $462;
              break L156;
             } else {
              $$032012$i = $460;$$032111$i = $462;
             }
            }
            HEAP32[$467>>2] = $338;
            $469 = ((($338)) + 24|0);
            HEAP32[$469>>2] = $$032111$i;
            $470 = ((($338)) + 12|0);
            HEAP32[$470>>2] = $338;
            $471 = ((($338)) + 8|0);
            HEAP32[$471>>2] = $338;
            break L139;
           }
          } while(0);
          $472 = ((($$0321$lcssa$i)) + 8|0);
          $473 = HEAP32[$472>>2]|0;
          $474 = ((($473)) + 12|0);
          HEAP32[$474>>2] = $338;
          HEAP32[$472>>2] = $338;
          $475 = ((($338)) + 8|0);
          HEAP32[$475>>2] = $473;
          $476 = ((($338)) + 12|0);
          HEAP32[$476>>2] = $$0321$lcssa$i;
          $477 = ((($338)) + 24|0);
          HEAP32[$477>>2] = 0;
         }
        } while(0);
        $478 = ((($$4$lcssa$i)) + 8|0);
        $$2 = $478;
       } else {
        $$0193 = $238;
        label = 118;
       }
      } else {
       $$0193 = $238;
       label = 118;
      }
     }
    }
   }
  }
 } while(0);
 L164: do {
  if ((label|0) == 118) {
   $479 = HEAP32[(55180)>>2]|0;
   $480 = ($479>>>0)<($$0193>>>0);
   if (!($480)) {
    $481 = (($479) - ($$0193))|0;
    $482 = HEAP32[(55192)>>2]|0;
    $483 = ($481>>>0)>(15);
    if ($483) {
     $484 = (($482) + ($$0193)|0);
     HEAP32[(55192)>>2] = $484;
     HEAP32[(55180)>>2] = $481;
     $485 = $481 | 1;
     $486 = ((($484)) + 4|0);
     HEAP32[$486>>2] = $485;
     $487 = (($482) + ($479)|0);
     HEAP32[$487>>2] = $481;
     $488 = $$0193 | 3;
     $489 = ((($482)) + 4|0);
     HEAP32[$489>>2] = $488;
    } else {
     HEAP32[(55180)>>2] = 0;
     HEAP32[(55192)>>2] = 0;
     $490 = $479 | 3;
     $491 = ((($482)) + 4|0);
     HEAP32[$491>>2] = $490;
     $492 = (($482) + ($479)|0);
     $493 = ((($492)) + 4|0);
     $494 = HEAP32[$493>>2]|0;
     $495 = $494 | 1;
     HEAP32[$493>>2] = $495;
    }
    $496 = ((($482)) + 8|0);
    $$2 = $496;
    break;
   }
   $497 = HEAP32[(55184)>>2]|0;
   $498 = ($497>>>0)>($$0193>>>0);
   if ($498) {
    $499 = (($497) - ($$0193))|0;
    HEAP32[(55184)>>2] = $499;
    $500 = HEAP32[(55196)>>2]|0;
    $501 = (($500) + ($$0193)|0);
    HEAP32[(55196)>>2] = $501;
    $502 = $499 | 1;
    $503 = ((($501)) + 4|0);
    HEAP32[$503>>2] = $502;
    $504 = $$0193 | 3;
    $505 = ((($500)) + 4|0);
    HEAP32[$505>>2] = $504;
    $506 = ((($500)) + 8|0);
    $$2 = $506;
    break;
   }
   $507 = HEAP32[13780]|0;
   $508 = ($507|0)==(0);
   if ($508) {
    (___pthread_mutex_lock(55144)|0);
    $509 = HEAP32[13780]|0;
    $510 = ($509|0)==(0);
    if ($510) {
     HEAP32[(55128)>>2] = 4096;
     HEAP32[(55124)>>2] = 4096;
     HEAP32[(55132)>>2] = -1;
     HEAP32[(55136)>>2] = -1;
     HEAP32[(55140)>>2] = 2;
     HEAP32[(55616)>>2] = 2;
     $511 = (_pthread_mutexattr_init($1)|0);
     $512 = ($511|0)==(0);
     if ($512) {
      $513 = (_pthread_mutex_init((55620),$1)|0);
      $514 = ($513|0)==(0);
      if ($514) {
      }
     }
     $515 = $2;
     $516 = $515 & -16;
     $517 = $516 ^ 1431655768;
     Atomics_store(HEAP32,13780,$517)|0;
    }
    (___pthread_mutex_unlock(55144)|0);
   }
   $518 = (($$0193) + 48)|0;
   $519 = HEAP32[(55128)>>2]|0;
   $520 = (($$0193) + 47)|0;
   $521 = (($519) + ($520))|0;
   $522 = (0 - ($519))|0;
   $523 = $521 & $522;
   $524 = ($523>>>0)>($$0193>>>0);
   if ($524) {
    $525 = HEAP32[(55612)>>2]|0;
    $526 = ($525|0)==(0);
    if (!($526)) {
     $527 = HEAP32[(55604)>>2]|0;
     $528 = (($527) + ($523))|0;
     $529 = ($528>>>0)<=($527>>>0);
     $530 = ($528>>>0)>($525>>>0);
     $or$cond1$i203 = $529 | $530;
     if ($or$cond1$i203) {
      $$2 = 0;
      break;
     }
    }
    $531 = HEAP32[(55616)>>2]|0;
    $532 = $531 & 4;
    $533 = ($532|0)==(0);
    if ($533) {
     $534 = HEAP32[(55196)>>2]|0;
     $535 = ($534|0)==(0|0);
     L192: do {
      if ($535) {
       label = 141;
      } else {
       $$0$i$i = (55648);
       while(1) {
        $536 = HEAP32[$$0$i$i>>2]|0;
        $537 = ($536>>>0)>($534>>>0);
        if (!($537)) {
         $538 = ((($$0$i$i)) + 4|0);
         $539 = HEAP32[$538>>2]|0;
         $540 = (($536) + ($539)|0);
         $541 = ($540>>>0)>($534>>>0);
         if ($541) {
          break;
         }
        }
        $542 = ((($$0$i$i)) + 8|0);
        $543 = HEAP32[$542>>2]|0;
        $544 = ($543|0)==(0|0);
        if ($544) {
         label = 141;
         break L192;
        } else {
         $$0$i$i = $543;
        }
       }
       (___pthread_mutex_lock(55144)|0);
       $567 = HEAP32[(55184)>>2]|0;
       $568 = HEAP32[(55128)>>2]|0;
       $569 = (($520) - ($567))|0;
       $570 = (($569) + ($568))|0;
       $571 = (0 - ($568))|0;
       $572 = $570 & $571;
       $573 = ($572>>>0)<(2147483647);
       if ($573) {
        $574 = ((($$0$i$i)) + 4|0);
        $575 = (_sbrk(($572|0))|0);
        $576 = HEAP32[$$0$i$i>>2]|0;
        $577 = HEAP32[$574>>2]|0;
        $578 = (($576) + ($577)|0);
        $579 = ($575|0)==($578|0);
        if ($579) {
         $580 = ($575|0)==((-1)|0);
         if ($580) {
          $$2234243136$i = $572;
          label = 155;
         } else {
          $$3229$i = $575;$$3235$i = $572;
         }
        } else {
         $$2247$ph$i = $575;$$2253$ph$i = $572;
         label = 149;
        }
       } else {
        $$2234243136$i = 0;
        label = 155;
       }
      }
     } while(0);
     do {
      if ((label|0) == 141) {
       (___pthread_mutex_lock(55144)|0);
       $545 = (_sbrk(0)|0);
       $546 = ($545|0)==((-1)|0);
       if ($546) {
        $$2234243136$i = 0;
        label = 155;
       } else {
        $547 = $545;
        $548 = HEAP32[(55124)>>2]|0;
        $549 = (($548) + -1)|0;
        $550 = $549 & $547;
        $551 = ($550|0)==(0);
        $552 = (($549) + ($547))|0;
        $553 = (0 - ($548))|0;
        $554 = $552 & $553;
        $555 = (($554) - ($547))|0;
        $556 = $551 ? 0 : $555;
        $spec$select42$i = (($556) + ($523))|0;
        $557 = HEAP32[(55604)>>2]|0;
        $558 = (($spec$select42$i) + ($557))|0;
        $559 = ($spec$select42$i>>>0)>($$0193>>>0);
        $560 = ($spec$select42$i>>>0)<(2147483647);
        $or$cond$i205 = $559 & $560;
        if ($or$cond$i205) {
         $561 = HEAP32[(55612)>>2]|0;
         $562 = ($561|0)==(0);
         if (!($562)) {
          $563 = ($558>>>0)<=($557>>>0);
          $564 = ($558>>>0)>($561>>>0);
          $or$cond2$i = $563 | $564;
          if ($or$cond2$i) {
           $$2234243136$i = 0;
           label = 155;
           break;
          }
         }
         $565 = (_sbrk(($spec$select42$i|0))|0);
         $566 = ($565|0)==($545|0);
         if ($566) {
          $$3229$i = $545;$$3235$i = $spec$select42$i;
         } else {
          $$2247$ph$i = $565;$$2253$ph$i = $spec$select42$i;
          label = 149;
         }
        } else {
         $$2234243136$i = 0;
         label = 155;
        }
       }
      }
     } while(0);
     do {
      if ((label|0) == 149) {
       $581 = (0 - ($$2253$ph$i))|0;
       $582 = ($$2247$ph$i|0)!=((-1)|0);
       $583 = ($$2253$ph$i>>>0)<(2147483647);
       $or$cond7$i = $583 & $582;
       $584 = ($518>>>0)>($$2253$ph$i>>>0);
       $or$cond6$i = $584 & $or$cond7$i;
       if (!($or$cond6$i)) {
        $594 = ($$2247$ph$i|0)==((-1)|0);
        if ($594) {
         $$2234243136$i = 0;
         label = 155;
         break;
        } else {
         $$3229$i = $$2247$ph$i;$$3235$i = $$2253$ph$i;
         break;
        }
       }
       $585 = HEAP32[(55128)>>2]|0;
       $586 = (($520) - ($$2253$ph$i))|0;
       $587 = (($586) + ($585))|0;
       $588 = (0 - ($585))|0;
       $589 = $587 & $588;
       $590 = ($589>>>0)<(2147483647);
       if ($590) {
        $591 = (_sbrk(($589|0))|0);
        $592 = ($591|0)==((-1)|0);
        if ($592) {
         (_sbrk(($581|0))|0);
         $$2234243136$i = 0;
         label = 155;
         break;
        } else {
         $593 = (($589) + ($$2253$ph$i))|0;
         $$3229$i = $$2247$ph$i;$$3235$i = $593;
         break;
        }
       } else {
        $$3229$i = $$2247$ph$i;$$3235$i = $$2253$ph$i;
       }
      }
     } while(0);
     if ((label|0) == 155) {
      $595 = HEAP32[(55616)>>2]|0;
      $596 = $595 | 4;
      HEAP32[(55616)>>2] = $596;
      $$3229$i = (-1);$$3235$i = $$2234243136$i;
     }
     (___pthread_mutex_unlock(55144)|0);
     $$4230$i = $$3229$i;$$4236$i = $$3235$i;
    } else {
     $$4230$i = (-1);$$4236$i = 0;
    }
    $597 = ($$4230$i|0)==((-1)|0);
    $598 = ($523>>>0)<(2147483647);
    $or$cond9$i = $598 & $597;
    if ($or$cond9$i) {
     (___pthread_mutex_lock(55144)|0);
     $599 = (_sbrk(($523|0))|0);
     $600 = (_sbrk(0)|0);
     (___pthread_mutex_unlock(55144)|0);
     $601 = ($599|0)!=((-1)|0);
     $602 = ($600|0)!=((-1)|0);
     $or$cond5$i = $601 & $602;
     $603 = ($599>>>0)<($600>>>0);
     $or$cond8$i = $603 & $or$cond5$i;
     $604 = $600;
     $605 = $599;
     $606 = (($604) - ($605))|0;
     $607 = (($$0193) + 40)|0;
     $608 = ($606>>>0)>($607>>>0);
     $spec$select9$i = $608 ? $606 : $$4236$i;
     $spec$select10$i = $608 ? $599 : (-1);
     if ($or$cond8$i) {
      $$7$i = $spec$select10$i;$$7239$i = $spec$select9$i;
      label = 159;
     }
    } else {
     $$7$i = $$4230$i;$$7239$i = $$4236$i;
     label = 159;
    }
    if ((label|0) == 159) {
     $609 = ($$7$i|0)==((-1)|0);
     if (!($609)) {
      $610 = HEAP32[(55604)>>2]|0;
      $611 = (($610) + ($$7239$i))|0;
      HEAP32[(55604)>>2] = $611;
      $612 = HEAP32[(55608)>>2]|0;
      $613 = ($611>>>0)>($612>>>0);
      if ($613) {
       HEAP32[(55608)>>2] = $611;
      }
      $614 = HEAP32[(55196)>>2]|0;
      $615 = ($614|0)==(0|0);
      L230: do {
       if ($615) {
        $616 = HEAP32[(55188)>>2]|0;
        $617 = ($616|0)==(0|0);
        $618 = ($$7$i>>>0)<($616>>>0);
        $or$cond11$i = $617 | $618;
        if ($or$cond11$i) {
         HEAP32[(55188)>>2] = $$7$i;
        }
        HEAP32[(55648)>>2] = $$7$i;
        HEAP32[(55652)>>2] = $$7239$i;
        HEAP32[(55660)>>2] = 0;
        $619 = HEAP32[13780]|0;
        HEAP32[(55208)>>2] = $619;
        HEAP32[(55204)>>2] = -1;
        HEAP32[(55224)>>2] = (55212);
        HEAP32[(55220)>>2] = (55212);
        HEAP32[(55232)>>2] = (55220);
        HEAP32[(55228)>>2] = (55220);
        HEAP32[(55240)>>2] = (55228);
        HEAP32[(55236)>>2] = (55228);
        HEAP32[(55248)>>2] = (55236);
        HEAP32[(55244)>>2] = (55236);
        HEAP32[(55256)>>2] = (55244);
        HEAP32[(55252)>>2] = (55244);
        HEAP32[(55264)>>2] = (55252);
        HEAP32[(55260)>>2] = (55252);
        HEAP32[(55272)>>2] = (55260);
        HEAP32[(55268)>>2] = (55260);
        HEAP32[(55280)>>2] = (55268);
        HEAP32[(55276)>>2] = (55268);
        HEAP32[(55288)>>2] = (55276);
        HEAP32[(55284)>>2] = (55276);
        HEAP32[(55296)>>2] = (55284);
        HEAP32[(55292)>>2] = (55284);
        HEAP32[(55304)>>2] = (55292);
        HEAP32[(55300)>>2] = (55292);
        HEAP32[(55312)>>2] = (55300);
        HEAP32[(55308)>>2] = (55300);
        HEAP32[(55320)>>2] = (55308);
        HEAP32[(55316)>>2] = (55308);
        HEAP32[(55328)>>2] = (55316);
        HEAP32[(55324)>>2] = (55316);
        HEAP32[(55336)>>2] = (55324);
        HEAP32[(55332)>>2] = (55324);
        HEAP32[(55344)>>2] = (55332);
        HEAP32[(55340)>>2] = (55332);
        HEAP32[(55352)>>2] = (55340);
        HEAP32[(55348)>>2] = (55340);
        HEAP32[(55360)>>2] = (55348);
        HEAP32[(55356)>>2] = (55348);
        HEAP32[(55368)>>2] = (55356);
        HEAP32[(55364)>>2] = (55356);
        HEAP32[(55376)>>2] = (55364);
        HEAP32[(55372)>>2] = (55364);
        HEAP32[(55384)>>2] = (55372);
        HEAP32[(55380)>>2] = (55372);
        HEAP32[(55392)>>2] = (55380);
        HEAP32[(55388)>>2] = (55380);
        HEAP32[(55400)>>2] = (55388);
        HEAP32[(55396)>>2] = (55388);
        HEAP32[(55408)>>2] = (55396);
        HEAP32[(55404)>>2] = (55396);
        HEAP32[(55416)>>2] = (55404);
        HEAP32[(55412)>>2] = (55404);
        HEAP32[(55424)>>2] = (55412);
        HEAP32[(55420)>>2] = (55412);
        HEAP32[(55432)>>2] = (55420);
        HEAP32[(55428)>>2] = (55420);
        HEAP32[(55440)>>2] = (55428);
        HEAP32[(55436)>>2] = (55428);
        HEAP32[(55448)>>2] = (55436);
        HEAP32[(55444)>>2] = (55436);
        HEAP32[(55456)>>2] = (55444);
        HEAP32[(55452)>>2] = (55444);
        HEAP32[(55464)>>2] = (55452);
        HEAP32[(55460)>>2] = (55452);
        HEAP32[(55472)>>2] = (55460);
        HEAP32[(55468)>>2] = (55460);
        $620 = (($$7239$i) + -40)|0;
        $621 = ((($$7$i)) + 8|0);
        $622 = $621;
        $623 = $622 & 7;
        $624 = ($623|0)==(0);
        $625 = (0 - ($622))|0;
        $626 = $625 & 7;
        $627 = $624 ? 0 : $626;
        $628 = (($$7$i) + ($627)|0);
        $629 = (($620) - ($627))|0;
        HEAP32[(55196)>>2] = $628;
        HEAP32[(55184)>>2] = $629;
        $630 = $629 | 1;
        $631 = ((($628)) + 4|0);
        HEAP32[$631>>2] = $630;
        $632 = (($$7$i) + ($620)|0);
        $633 = ((($632)) + 4|0);
        HEAP32[$633>>2] = 40;
        $634 = HEAP32[(55136)>>2]|0;
        HEAP32[(55200)>>2] = $634;
       } else {
        $$024364$i = (55648);
        while(1) {
         $635 = HEAP32[$$024364$i>>2]|0;
         $636 = ((($$024364$i)) + 4|0);
         $637 = HEAP32[$636>>2]|0;
         $638 = (($635) + ($637)|0);
         $639 = ($$7$i|0)==($638|0);
         if ($639) {
          label = 169;
          break;
         }
         $640 = ((($$024364$i)) + 8|0);
         $641 = HEAP32[$640>>2]|0;
         $642 = ($641|0)==(0|0);
         if ($642) {
          break;
         } else {
          $$024364$i = $641;
         }
        }
        if ((label|0) == 169) {
         $643 = ((($$024364$i)) + 4|0);
         $644 = ((($$024364$i)) + 12|0);
         $645 = HEAP32[$644>>2]|0;
         $646 = $645 & 8;
         $647 = ($646|0)==(0);
         if ($647) {
          $648 = ($635>>>0)<=($614>>>0);
          $649 = ($$7$i>>>0)>($614>>>0);
          $or$cond43$i = $649 & $648;
          if ($or$cond43$i) {
           $650 = (($637) + ($$7239$i))|0;
           HEAP32[$643>>2] = $650;
           $651 = HEAP32[(55184)>>2]|0;
           $652 = (($651) + ($$7239$i))|0;
           $653 = ((($614)) + 8|0);
           $654 = $653;
           $655 = $654 & 7;
           $656 = ($655|0)==(0);
           $657 = (0 - ($654))|0;
           $658 = $657 & 7;
           $659 = $656 ? 0 : $658;
           $660 = (($614) + ($659)|0);
           $661 = (($652) - ($659))|0;
           HEAP32[(55196)>>2] = $660;
           HEAP32[(55184)>>2] = $661;
           $662 = $661 | 1;
           $663 = ((($660)) + 4|0);
           HEAP32[$663>>2] = $662;
           $664 = (($614) + ($652)|0);
           $665 = ((($664)) + 4|0);
           HEAP32[$665>>2] = 40;
           $666 = HEAP32[(55136)>>2]|0;
           HEAP32[(55200)>>2] = $666;
           break;
          }
         }
        }
        $667 = HEAP32[(55188)>>2]|0;
        $668 = ($$7$i>>>0)<($667>>>0);
        if ($668) {
         HEAP32[(55188)>>2] = $$7$i;
        }
        $669 = (($$7$i) + ($$7239$i)|0);
        $$124463$i = (55648);
        while(1) {
         $670 = HEAP32[$$124463$i>>2]|0;
         $671 = ($670|0)==($669|0);
         if ($671) {
          label = 177;
          break;
         }
         $672 = ((($$124463$i)) + 8|0);
         $673 = HEAP32[$672>>2]|0;
         $674 = ($673|0)==(0|0);
         if ($674) {
          break;
         } else {
          $$124463$i = $673;
         }
        }
        if ((label|0) == 177) {
         $675 = ((($$124463$i)) + 12|0);
         $676 = HEAP32[$675>>2]|0;
         $677 = $676 & 8;
         $678 = ($677|0)==(0);
         if ($678) {
          HEAP32[$$124463$i>>2] = $$7$i;
          $679 = ((($$124463$i)) + 4|0);
          $680 = HEAP32[$679>>2]|0;
          $681 = (($680) + ($$7239$i))|0;
          HEAP32[$679>>2] = $681;
          $682 = ((($$7$i)) + 8|0);
          $683 = $682;
          $684 = $683 & 7;
          $685 = ($684|0)==(0);
          $686 = (0 - ($683))|0;
          $687 = $686 & 7;
          $688 = $685 ? 0 : $687;
          $689 = (($$7$i) + ($688)|0);
          $690 = ((($669)) + 8|0);
          $691 = $690;
          $692 = $691 & 7;
          $693 = ($692|0)==(0);
          $694 = (0 - ($691))|0;
          $695 = $694 & 7;
          $696 = $693 ? 0 : $695;
          $697 = (($669) + ($696)|0);
          $698 = $697;
          $699 = $689;
          $700 = (($698) - ($699))|0;
          $701 = (($689) + ($$0193)|0);
          $702 = (($700) - ($$0193))|0;
          $703 = $$0193 | 3;
          $704 = ((($689)) + 4|0);
          HEAP32[$704>>2] = $703;
          $705 = ($614|0)==($697|0);
          L253: do {
           if ($705) {
            $706 = HEAP32[(55184)>>2]|0;
            $707 = (($706) + ($702))|0;
            HEAP32[(55184)>>2] = $707;
            HEAP32[(55196)>>2] = $701;
            $708 = $707 | 1;
            $709 = ((($701)) + 4|0);
            HEAP32[$709>>2] = $708;
           } else {
            $710 = HEAP32[(55192)>>2]|0;
            $711 = ($710|0)==($697|0);
            if ($711) {
             $712 = HEAP32[(55180)>>2]|0;
             $713 = (($712) + ($702))|0;
             HEAP32[(55180)>>2] = $713;
             HEAP32[(55192)>>2] = $701;
             $714 = $713 | 1;
             $715 = ((($701)) + 4|0);
             HEAP32[$715>>2] = $714;
             $716 = (($701) + ($713)|0);
             HEAP32[$716>>2] = $713;
             break;
            }
            $717 = ((($697)) + 4|0);
            $718 = HEAP32[$717>>2]|0;
            $719 = $718 & 3;
            $720 = ($719|0)==(1);
            if ($720) {
             $721 = $718 & -8;
             $722 = $718 >>> 3;
             $723 = ($718>>>0)<(256);
             L261: do {
              if ($723) {
               $724 = ((($697)) + 8|0);
               $725 = HEAP32[$724>>2]|0;
               $726 = ((($697)) + 12|0);
               $727 = HEAP32[$726>>2]|0;
               $728 = ($727|0)==($725|0);
               if ($728) {
                $729 = 1 << $722;
                $730 = $729 ^ -1;
                $731 = HEAP32[13793]|0;
                $732 = $731 & $730;
                HEAP32[13793] = $732;
                break;
               } else {
                $733 = ((($725)) + 12|0);
                HEAP32[$733>>2] = $727;
                $734 = ((($727)) + 8|0);
                HEAP32[$734>>2] = $725;
                break;
               }
              } else {
               $735 = ((($697)) + 24|0);
               $736 = HEAP32[$735>>2]|0;
               $737 = ((($697)) + 12|0);
               $738 = HEAP32[$737>>2]|0;
               $739 = ($738|0)==($697|0);
               do {
                if ($739) {
                 $744 = ((($697)) + 16|0);
                 $745 = ((($744)) + 4|0);
                 $746 = HEAP32[$745>>2]|0;
                 $747 = ($746|0)==(0|0);
                 if ($747) {
                  $748 = HEAP32[$744>>2]|0;
                  $749 = ($748|0)==(0|0);
                  if ($749) {
                   $$3$i$i = 0;
                   break;
                  } else {
                   $$1263$i$i$ph = $748;$$1265$i$i$ph = $744;
                  }
                 } else {
                  $$1263$i$i$ph = $746;$$1265$i$i$ph = $745;
                 }
                 $$1263$i$i = $$1263$i$i$ph;$$1265$i$i = $$1265$i$i$ph;
                 while(1) {
                  $750 = ((($$1263$i$i)) + 20|0);
                  $751 = HEAP32[$750>>2]|0;
                  $752 = ($751|0)==(0|0);
                  if ($752) {
                   $753 = ((($$1263$i$i)) + 16|0);
                   $754 = HEAP32[$753>>2]|0;
                   $755 = ($754|0)==(0|0);
                   if ($755) {
                    break;
                   } else {
                    $$1263$i$i$be = $754;$$1265$i$i$be = $753;
                   }
                  } else {
                   $$1263$i$i$be = $751;$$1265$i$i$be = $750;
                  }
                  $$1263$i$i = $$1263$i$i$be;$$1265$i$i = $$1265$i$i$be;
                 }
                 HEAP32[$$1265$i$i>>2] = 0;
                 $$3$i$i = $$1263$i$i;
                } else {
                 $740 = ((($697)) + 8|0);
                 $741 = HEAP32[$740>>2]|0;
                 $742 = ((($741)) + 12|0);
                 HEAP32[$742>>2] = $738;
                 $743 = ((($738)) + 8|0);
                 HEAP32[$743>>2] = $741;
                 $$3$i$i = $738;
                }
               } while(0);
               $756 = ($736|0)==(0|0);
               if ($756) {
                break;
               }
               $757 = ((($697)) + 28|0);
               $758 = HEAP32[$757>>2]|0;
               $759 = (55476 + ($758<<2)|0);
               $760 = HEAP32[$759>>2]|0;
               $761 = ($760|0)==($697|0);
               do {
                if ($761) {
                 HEAP32[$759>>2] = $$3$i$i;
                 $cond$i$i = ($$3$i$i|0)==(0|0);
                 if (!($cond$i$i)) {
                  break;
                 }
                 $762 = 1 << $758;
                 $763 = $762 ^ -1;
                 $764 = HEAP32[(55176)>>2]|0;
                 $765 = $764 & $763;
                 HEAP32[(55176)>>2] = $765;
                 break L261;
                } else {
                 $766 = ((($736)) + 16|0);
                 $767 = HEAP32[$766>>2]|0;
                 $768 = ($767|0)==($697|0);
                 $769 = ((($736)) + 20|0);
                 $$sink320 = $768 ? $766 : $769;
                 HEAP32[$$sink320>>2] = $$3$i$i;
                 $770 = ($$3$i$i|0)==(0|0);
                 if ($770) {
                  break L261;
                 }
                }
               } while(0);
               $771 = ((($$3$i$i)) + 24|0);
               HEAP32[$771>>2] = $736;
               $772 = ((($697)) + 16|0);
               $773 = HEAP32[$772>>2]|0;
               $774 = ($773|0)==(0|0);
               if (!($774)) {
                $775 = ((($$3$i$i)) + 16|0);
                HEAP32[$775>>2] = $773;
                $776 = ((($773)) + 24|0);
                HEAP32[$776>>2] = $$3$i$i;
               }
               $777 = ((($772)) + 4|0);
               $778 = HEAP32[$777>>2]|0;
               $779 = ($778|0)==(0|0);
               if ($779) {
                break;
               }
               $780 = ((($$3$i$i)) + 20|0);
               HEAP32[$780>>2] = $778;
               $781 = ((($778)) + 24|0);
               HEAP32[$781>>2] = $$3$i$i;
              }
             } while(0);
             $782 = (($697) + ($721)|0);
             $783 = (($721) + ($702))|0;
             $$0$i16$i = $782;$$0259$i$i = $783;
            } else {
             $$0$i16$i = $697;$$0259$i$i = $702;
            }
            $784 = ((($$0$i16$i)) + 4|0);
            $785 = HEAP32[$784>>2]|0;
            $786 = $785 & -2;
            HEAP32[$784>>2] = $786;
            $787 = $$0259$i$i | 1;
            $788 = ((($701)) + 4|0);
            HEAP32[$788>>2] = $787;
            $789 = (($701) + ($$0259$i$i)|0);
            HEAP32[$789>>2] = $$0259$i$i;
            $790 = $$0259$i$i >>> 3;
            $791 = ($$0259$i$i>>>0)<(256);
            if ($791) {
             $792 = $790 << 1;
             $793 = (55212 + ($792<<2)|0);
             $794 = HEAP32[13793]|0;
             $795 = 1 << $790;
             $796 = $794 & $795;
             $797 = ($796|0)==(0);
             if ($797) {
              $798 = $794 | $795;
              HEAP32[13793] = $798;
              $$pre$i$i = ((($793)) + 8|0);
              $$0267$i$i = $793;$$pre$phi$i$iZ2D = $$pre$i$i;
             } else {
              $799 = ((($793)) + 8|0);
              $800 = HEAP32[$799>>2]|0;
              $$0267$i$i = $800;$$pre$phi$i$iZ2D = $799;
             }
             HEAP32[$$pre$phi$i$iZ2D>>2] = $701;
             $801 = ((($$0267$i$i)) + 12|0);
             HEAP32[$801>>2] = $701;
             $802 = ((($701)) + 8|0);
             HEAP32[$802>>2] = $$0267$i$i;
             $803 = ((($701)) + 12|0);
             HEAP32[$803>>2] = $793;
             break;
            }
            $804 = $$0259$i$i >>> 8;
            $805 = ($804|0)==(0);
            do {
             if ($805) {
              $$0268$i$i = 0;
             } else {
              $806 = ($$0259$i$i>>>0)>(16777215);
              if ($806) {
               $$0268$i$i = 31;
               break;
              }
              $807 = (($804) + 1048320)|0;
              $808 = $807 >>> 16;
              $809 = $808 & 8;
              $810 = $804 << $809;
              $811 = (($810) + 520192)|0;
              $812 = $811 >>> 16;
              $813 = $812 & 4;
              $814 = $813 | $809;
              $815 = $810 << $813;
              $816 = (($815) + 245760)|0;
              $817 = $816 >>> 16;
              $818 = $817 & 2;
              $819 = $814 | $818;
              $820 = (14 - ($819))|0;
              $821 = $815 << $818;
              $822 = $821 >>> 15;
              $823 = (($820) + ($822))|0;
              $824 = $823 << 1;
              $825 = (($823) + 7)|0;
              $826 = $$0259$i$i >>> $825;
              $827 = $826 & 1;
              $828 = $827 | $824;
              $$0268$i$i = $828;
             }
            } while(0);
            $829 = (55476 + ($$0268$i$i<<2)|0);
            $830 = ((($701)) + 28|0);
            HEAP32[$830>>2] = $$0268$i$i;
            $831 = ((($701)) + 16|0);
            $832 = ((($831)) + 4|0);
            HEAP32[$832>>2] = 0;
            HEAP32[$831>>2] = 0;
            $833 = HEAP32[(55176)>>2]|0;
            $834 = 1 << $$0268$i$i;
            $835 = $833 & $834;
            $836 = ($835|0)==(0);
            if ($836) {
             $837 = $833 | $834;
             HEAP32[(55176)>>2] = $837;
             HEAP32[$829>>2] = $701;
             $838 = ((($701)) + 24|0);
             HEAP32[$838>>2] = $829;
             $839 = ((($701)) + 12|0);
             HEAP32[$839>>2] = $701;
             $840 = ((($701)) + 8|0);
             HEAP32[$840>>2] = $701;
             break;
            }
            $841 = HEAP32[$829>>2]|0;
            $842 = ((($841)) + 4|0);
            $843 = HEAP32[$842>>2]|0;
            $844 = $843 & -8;
            $845 = ($844|0)==($$0259$i$i|0);
            L306: do {
             if ($845) {
              $$0261$lcssa$i$i = $841;
             } else {
              $846 = ($$0268$i$i|0)==(31);
              $847 = $$0268$i$i >>> 1;
              $848 = (25 - ($847))|0;
              $849 = $846 ? 0 : $848;
              $850 = $$0259$i$i << $849;
              $$02604$i$i = $850;$$02613$i$i = $841;
              while(1) {
               $857 = $$02604$i$i >>> 31;
               $858 = (((($$02613$i$i)) + 16|0) + ($857<<2)|0);
               $853 = HEAP32[$858>>2]|0;
               $859 = ($853|0)==(0|0);
               if ($859) {
                break;
               }
               $851 = $$02604$i$i << 1;
               $852 = ((($853)) + 4|0);
               $854 = HEAP32[$852>>2]|0;
               $855 = $854 & -8;
               $856 = ($855|0)==($$0259$i$i|0);
               if ($856) {
                $$0261$lcssa$i$i = $853;
                break L306;
               } else {
                $$02604$i$i = $851;$$02613$i$i = $853;
               }
              }
              HEAP32[$858>>2] = $701;
              $860 = ((($701)) + 24|0);
              HEAP32[$860>>2] = $$02613$i$i;
              $861 = ((($701)) + 12|0);
              HEAP32[$861>>2] = $701;
              $862 = ((($701)) + 8|0);
              HEAP32[$862>>2] = $701;
              break L253;
             }
            } while(0);
            $863 = ((($$0261$lcssa$i$i)) + 8|0);
            $864 = HEAP32[$863>>2]|0;
            $865 = ((($864)) + 12|0);
            HEAP32[$865>>2] = $701;
            HEAP32[$863>>2] = $701;
            $866 = ((($701)) + 8|0);
            HEAP32[$866>>2] = $864;
            $867 = ((($701)) + 12|0);
            HEAP32[$867>>2] = $$0261$lcssa$i$i;
            $868 = ((($701)) + 24|0);
            HEAP32[$868>>2] = 0;
           }
          } while(0);
          $997 = ((($689)) + 8|0);
          $$2 = $997;
          break L164;
         }
        }
        $$0$i$i$i = (55648);
        while(1) {
         $869 = HEAP32[$$0$i$i$i>>2]|0;
         $870 = ($869>>>0)>($614>>>0);
         if (!($870)) {
          $871 = ((($$0$i$i$i)) + 4|0);
          $872 = HEAP32[$871>>2]|0;
          $873 = (($869) + ($872)|0);
          $874 = ($873>>>0)>($614>>>0);
          if ($874) {
           break;
          }
         }
         $875 = ((($$0$i$i$i)) + 8|0);
         $876 = HEAP32[$875>>2]|0;
         $$0$i$i$i = $876;
        }
        $877 = ((($873)) + -47|0);
        $878 = ((($877)) + 8|0);
        $879 = $878;
        $880 = $879 & 7;
        $881 = ($880|0)==(0);
        $882 = (0 - ($879))|0;
        $883 = $882 & 7;
        $884 = $881 ? 0 : $883;
        $885 = (($877) + ($884)|0);
        $886 = ((($614)) + 16|0);
        $887 = ($885>>>0)<($886>>>0);
        $888 = $887 ? $614 : $885;
        $889 = ((($888)) + 8|0);
        $890 = ((($888)) + 24|0);
        $891 = (($$7239$i) + -40)|0;
        $892 = ((($$7$i)) + 8|0);
        $893 = $892;
        $894 = $893 & 7;
        $895 = ($894|0)==(0);
        $896 = (0 - ($893))|0;
        $897 = $896 & 7;
        $898 = $895 ? 0 : $897;
        $899 = (($$7$i) + ($898)|0);
        $900 = (($891) - ($898))|0;
        HEAP32[(55196)>>2] = $899;
        HEAP32[(55184)>>2] = $900;
        $901 = $900 | 1;
        $902 = ((($899)) + 4|0);
        HEAP32[$902>>2] = $901;
        $903 = (($$7$i) + ($891)|0);
        $904 = ((($903)) + 4|0);
        HEAP32[$904>>2] = 40;
        $905 = HEAP32[(55136)>>2]|0;
        HEAP32[(55200)>>2] = $905;
        $906 = ((($888)) + 4|0);
        HEAP32[$906>>2] = 27;
        ;HEAP32[$889>>2]=HEAP32[(55648)>>2]|0;HEAP32[$889+4>>2]=HEAP32[(55648)+4>>2]|0;HEAP32[$889+8>>2]=HEAP32[(55648)+8>>2]|0;HEAP32[$889+12>>2]=HEAP32[(55648)+12>>2]|0;
        HEAP32[(55648)>>2] = $$7$i;
        HEAP32[(55652)>>2] = $$7239$i;
        HEAP32[(55660)>>2] = 0;
        HEAP32[(55656)>>2] = $889;
        $908 = $890;
        while(1) {
         $907 = ((($908)) + 4|0);
         HEAP32[$907>>2] = 7;
         $909 = ((($908)) + 8|0);
         $910 = ($909>>>0)<($873>>>0);
         if ($910) {
          $908 = $907;
         } else {
          break;
         }
        }
        $911 = ($888|0)==($614|0);
        if (!($911)) {
         $912 = $888;
         $913 = $614;
         $914 = (($912) - ($913))|0;
         $915 = HEAP32[$906>>2]|0;
         $916 = $915 & -2;
         HEAP32[$906>>2] = $916;
         $917 = $914 | 1;
         $918 = ((($614)) + 4|0);
         HEAP32[$918>>2] = $917;
         HEAP32[$888>>2] = $914;
         $919 = $914 >>> 3;
         $920 = ($914>>>0)<(256);
         if ($920) {
          $921 = $919 << 1;
          $922 = (55212 + ($921<<2)|0);
          $923 = HEAP32[13793]|0;
          $924 = 1 << $919;
          $925 = $923 & $924;
          $926 = ($925|0)==(0);
          if ($926) {
           $927 = $923 | $924;
           HEAP32[13793] = $927;
           $$pre$i17$i = ((($922)) + 8|0);
           $$0206$i$i = $922;$$pre$phi$i18$iZ2D = $$pre$i17$i;
          } else {
           $928 = ((($922)) + 8|0);
           $929 = HEAP32[$928>>2]|0;
           $$0206$i$i = $929;$$pre$phi$i18$iZ2D = $928;
          }
          HEAP32[$$pre$phi$i18$iZ2D>>2] = $614;
          $930 = ((($$0206$i$i)) + 12|0);
          HEAP32[$930>>2] = $614;
          $931 = ((($614)) + 8|0);
          HEAP32[$931>>2] = $$0206$i$i;
          $932 = ((($614)) + 12|0);
          HEAP32[$932>>2] = $922;
          break;
         }
         $933 = $914 >>> 8;
         $934 = ($933|0)==(0);
         do {
          if ($934) {
           $$0207$i$i = 0;
          } else {
           $935 = ($914>>>0)>(16777215);
           if ($935) {
            $$0207$i$i = 31;
            break;
           }
           $936 = (($933) + 1048320)|0;
           $937 = $936 >>> 16;
           $938 = $937 & 8;
           $939 = $933 << $938;
           $940 = (($939) + 520192)|0;
           $941 = $940 >>> 16;
           $942 = $941 & 4;
           $943 = $942 | $938;
           $944 = $939 << $942;
           $945 = (($944) + 245760)|0;
           $946 = $945 >>> 16;
           $947 = $946 & 2;
           $948 = $943 | $947;
           $949 = (14 - ($948))|0;
           $950 = $944 << $947;
           $951 = $950 >>> 15;
           $952 = (($949) + ($951))|0;
           $953 = $952 << 1;
           $954 = (($952) + 7)|0;
           $955 = $914 >>> $954;
           $956 = $955 & 1;
           $957 = $956 | $953;
           $$0207$i$i = $957;
          }
         } while(0);
         $958 = (55476 + ($$0207$i$i<<2)|0);
         $959 = ((($614)) + 28|0);
         HEAP32[$959>>2] = $$0207$i$i;
         $960 = ((($614)) + 20|0);
         HEAP32[$960>>2] = 0;
         HEAP32[$886>>2] = 0;
         $961 = HEAP32[(55176)>>2]|0;
         $962 = 1 << $$0207$i$i;
         $963 = $961 & $962;
         $964 = ($963|0)==(0);
         if ($964) {
          $965 = $961 | $962;
          HEAP32[(55176)>>2] = $965;
          HEAP32[$958>>2] = $614;
          $966 = ((($614)) + 24|0);
          HEAP32[$966>>2] = $958;
          $967 = ((($614)) + 12|0);
          HEAP32[$967>>2] = $614;
          $968 = ((($614)) + 8|0);
          HEAP32[$968>>2] = $614;
          break;
         }
         $969 = HEAP32[$958>>2]|0;
         $970 = ((($969)) + 4|0);
         $971 = HEAP32[$970>>2]|0;
         $972 = $971 & -8;
         $973 = ($972|0)==($914|0);
         L339: do {
          if ($973) {
           $$0202$lcssa$i$i = $969;
          } else {
           $974 = ($$0207$i$i|0)==(31);
           $975 = $$0207$i$i >>> 1;
           $976 = (25 - ($975))|0;
           $977 = $974 ? 0 : $976;
           $978 = $914 << $977;
           $$02014$i$i = $978;$$02023$i$i = $969;
           while(1) {
            $985 = $$02014$i$i >>> 31;
            $986 = (((($$02023$i$i)) + 16|0) + ($985<<2)|0);
            $981 = HEAP32[$986>>2]|0;
            $987 = ($981|0)==(0|0);
            if ($987) {
             break;
            }
            $979 = $$02014$i$i << 1;
            $980 = ((($981)) + 4|0);
            $982 = HEAP32[$980>>2]|0;
            $983 = $982 & -8;
            $984 = ($983|0)==($914|0);
            if ($984) {
             $$0202$lcssa$i$i = $981;
             break L339;
            } else {
             $$02014$i$i = $979;$$02023$i$i = $981;
            }
           }
           HEAP32[$986>>2] = $614;
           $988 = ((($614)) + 24|0);
           HEAP32[$988>>2] = $$02023$i$i;
           $989 = ((($614)) + 12|0);
           HEAP32[$989>>2] = $614;
           $990 = ((($614)) + 8|0);
           HEAP32[$990>>2] = $614;
           break L230;
          }
         } while(0);
         $991 = ((($$0202$lcssa$i$i)) + 8|0);
         $992 = HEAP32[$991>>2]|0;
         $993 = ((($992)) + 12|0);
         HEAP32[$993>>2] = $614;
         HEAP32[$991>>2] = $614;
         $994 = ((($614)) + 8|0);
         HEAP32[$994>>2] = $992;
         $995 = ((($614)) + 12|0);
         HEAP32[$995>>2] = $$0202$lcssa$i$i;
         $996 = ((($614)) + 24|0);
         HEAP32[$996>>2] = 0;
        }
       }
      } while(0);
      $998 = HEAP32[(55184)>>2]|0;
      $999 = ($998>>>0)>($$0193>>>0);
      if ($999) {
       $1000 = (($998) - ($$0193))|0;
       HEAP32[(55184)>>2] = $1000;
       $1001 = HEAP32[(55196)>>2]|0;
       $1002 = (($1001) + ($$0193)|0);
       HEAP32[(55196)>>2] = $1002;
       $1003 = $1000 | 1;
       $1004 = ((($1002)) + 4|0);
       HEAP32[$1004>>2] = $1003;
       $1005 = $$0193 | 3;
       $1006 = ((($1001)) + 4|0);
       HEAP32[$1006>>2] = $1005;
       $1007 = ((($1001)) + 8|0);
       $$2 = $1007;
       break;
      }
     }
    }
    $1008 = (___errno_location()|0);
    HEAP32[$1008>>2] = 12;
    $$2 = 0;
   } else {
    $$2 = 0;
   }
  }
 } while(0);
 $1009 = HEAP32[(55616)>>2]|0;
 $1010 = $1009 & 2;
 $1011 = ($1010|0)==(0);
 if ($1011) {
  $$1 = $$2;
  STACKTOP = sp;return ($$1|0);
 }
 (___pthread_mutex_unlock((55620))|0);
 $$1 = $$2;
 STACKTOP = sp;return ($$1|0);
}
function _free($0) {
 $0 = $0|0;
 var $$0194$i = 0, $$0194$in$i = 0, $$0346381 = 0, $$0347$lcssa = 0, $$0347380 = 0, $$0359 = 0, $$0366 = 0, $$1 = 0, $$1345 = 0, $$1350 = 0, $$1350$be = 0, $$1350$ph = 0, $$1353 = 0, $$1353$be = 0, $$1353$ph = 0, $$1361 = 0, $$1361$be = 0, $$1361$ph = 0, $$1365 = 0, $$1365$be = 0;
 var $$1365$ph = 0, $$2 = 0, $$3 = 0, $$3363 = 0, $$pre = 0, $$pre$phiZ2D = 0, $$sink = 0, $$sink395 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0;
 var $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0;
 var $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0;
 var $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0;
 var $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0;
 var $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0;
 var $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0;
 var $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0;
 var $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0;
 var $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0;
 var $272 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0;
 var $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0;
 var $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0;
 var $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0;
 var $cond371 = 0, $cond372 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $1 = ($0|0)==(0|0);
 if ($1) {
  return;
 }
 $2 = ((($0)) + -8|0);
 $3 = HEAP32[(55616)>>2]|0;
 $4 = $3 & 2;
 $5 = ($4|0)==(0);
 if (!($5)) {
  $6 = (___pthread_mutex_lock((55620))|0);
  $7 = ($6|0)==(0);
  if (!($7)) {
   return;
  }
 }
 $8 = HEAP32[(55188)>>2]|0;
 $9 = ((($0)) + -4|0);
 $10 = HEAP32[$9>>2]|0;
 $11 = $10 & -8;
 $12 = (($2) + ($11)|0);
 $13 = $10 & 1;
 $14 = ($13|0)==(0);
 do {
  if ($14) {
   $15 = HEAP32[$2>>2]|0;
   $16 = $10 & 3;
   $17 = ($16|0)==(0);
   if (!($17)) {
    $18 = (0 - ($15))|0;
    $19 = (($2) + ($18)|0);
    $20 = (($15) + ($11))|0;
    $21 = ($19>>>0)<($8>>>0);
    if (!($21)) {
     $22 = HEAP32[(55192)>>2]|0;
     $23 = ($22|0)==($19|0);
     if ($23) {
      $84 = ((($12)) + 4|0);
      $85 = HEAP32[$84>>2]|0;
      $86 = $85 & 3;
      $87 = ($86|0)==(3);
      if (!($87)) {
       $$1 = $19;$$1345 = $20;$92 = $19;
       label = 32;
       break;
      }
      $88 = (($19) + ($20)|0);
      $89 = ((($19)) + 4|0);
      $90 = $20 | 1;
      $91 = $85 & -2;
      HEAP32[(55180)>>2] = $20;
      HEAP32[$84>>2] = $91;
      HEAP32[$89>>2] = $90;
      HEAP32[$88>>2] = $20;
      break;
     }
     $24 = $15 >>> 3;
     $25 = ($15>>>0)<(256);
     if ($25) {
      $26 = ((($19)) + 8|0);
      $27 = HEAP32[$26>>2]|0;
      $28 = ((($19)) + 12|0);
      $29 = HEAP32[$28>>2]|0;
      $30 = ($29|0)==($27|0);
      if ($30) {
       $31 = 1 << $24;
       $32 = $31 ^ -1;
       $33 = HEAP32[13793]|0;
       $34 = $33 & $32;
       HEAP32[13793] = $34;
       $$1 = $19;$$1345 = $20;$92 = $19;
       label = 32;
       break;
      } else {
       $35 = ((($27)) + 12|0);
       HEAP32[$35>>2] = $29;
       $36 = ((($29)) + 8|0);
       HEAP32[$36>>2] = $27;
       $$1 = $19;$$1345 = $20;$92 = $19;
       label = 32;
       break;
      }
     }
     $37 = ((($19)) + 24|0);
     $38 = HEAP32[$37>>2]|0;
     $39 = ((($19)) + 12|0);
     $40 = HEAP32[$39>>2]|0;
     $41 = ($40|0)==($19|0);
     do {
      if ($41) {
       $46 = ((($19)) + 16|0);
       $47 = ((($46)) + 4|0);
       $48 = HEAP32[$47>>2]|0;
       $49 = ($48|0)==(0|0);
       if ($49) {
        $50 = HEAP32[$46>>2]|0;
        $51 = ($50|0)==(0|0);
        if ($51) {
         $$3 = 0;
         break;
        } else {
         $$1350$ph = $50;$$1353$ph = $46;
        }
       } else {
        $$1350$ph = $48;$$1353$ph = $47;
       }
       $$1350 = $$1350$ph;$$1353 = $$1353$ph;
       while(1) {
        $52 = ((($$1350)) + 20|0);
        $53 = HEAP32[$52>>2]|0;
        $54 = ($53|0)==(0|0);
        if ($54) {
         $55 = ((($$1350)) + 16|0);
         $56 = HEAP32[$55>>2]|0;
         $57 = ($56|0)==(0|0);
         if ($57) {
          break;
         } else {
          $$1350$be = $56;$$1353$be = $55;
         }
        } else {
         $$1350$be = $53;$$1353$be = $52;
        }
        $$1350 = $$1350$be;$$1353 = $$1353$be;
       }
       HEAP32[$$1353>>2] = 0;
       $$3 = $$1350;
      } else {
       $42 = ((($19)) + 8|0);
       $43 = HEAP32[$42>>2]|0;
       $44 = ((($43)) + 12|0);
       HEAP32[$44>>2] = $40;
       $45 = ((($40)) + 8|0);
       HEAP32[$45>>2] = $43;
       $$3 = $40;
      }
     } while(0);
     $58 = ($38|0)==(0|0);
     if ($58) {
      $$1 = $19;$$1345 = $20;$92 = $19;
      label = 32;
     } else {
      $59 = ((($19)) + 28|0);
      $60 = HEAP32[$59>>2]|0;
      $61 = (55476 + ($60<<2)|0);
      $62 = HEAP32[$61>>2]|0;
      $63 = ($62|0)==($19|0);
      if ($63) {
       HEAP32[$61>>2] = $$3;
       $cond371 = ($$3|0)==(0|0);
       if ($cond371) {
        $64 = 1 << $60;
        $65 = $64 ^ -1;
        $66 = HEAP32[(55176)>>2]|0;
        $67 = $66 & $65;
        HEAP32[(55176)>>2] = $67;
        $$1 = $19;$$1345 = $20;$92 = $19;
        label = 32;
        break;
       }
      } else {
       $68 = ((($38)) + 16|0);
       $69 = HEAP32[$68>>2]|0;
       $70 = ($69|0)==($19|0);
       $71 = ((($38)) + 20|0);
       $$sink = $70 ? $68 : $71;
       HEAP32[$$sink>>2] = $$3;
       $72 = ($$3|0)==(0|0);
       if ($72) {
        $$1 = $19;$$1345 = $20;$92 = $19;
        label = 32;
        break;
       }
      }
      $73 = ((($$3)) + 24|0);
      HEAP32[$73>>2] = $38;
      $74 = ((($19)) + 16|0);
      $75 = HEAP32[$74>>2]|0;
      $76 = ($75|0)==(0|0);
      if (!($76)) {
       $77 = ((($$3)) + 16|0);
       HEAP32[$77>>2] = $75;
       $78 = ((($75)) + 24|0);
       HEAP32[$78>>2] = $$3;
      }
      $79 = ((($74)) + 4|0);
      $80 = HEAP32[$79>>2]|0;
      $81 = ($80|0)==(0|0);
      if ($81) {
       $$1 = $19;$$1345 = $20;$92 = $19;
       label = 32;
      } else {
       $82 = ((($$3)) + 20|0);
       HEAP32[$82>>2] = $80;
       $83 = ((($80)) + 24|0);
       HEAP32[$83>>2] = $$3;
       $$1 = $19;$$1345 = $20;$92 = $19;
       label = 32;
      }
     }
    }
   }
  } else {
   $$1 = $2;$$1345 = $11;$92 = $2;
   label = 32;
  }
 } while(0);
 do {
  if ((label|0) == 32) {
   $93 = ($92>>>0)<($12>>>0);
   if ($93) {
    $94 = ((($12)) + 4|0);
    $95 = HEAP32[$94>>2]|0;
    $96 = $95 & 1;
    $97 = ($96|0)==(0);
    if (!($97)) {
     $98 = $95 & 2;
     $99 = ($98|0)==(0);
     if ($99) {
      $100 = HEAP32[(55196)>>2]|0;
      $101 = ($100|0)==($12|0);
      if ($101) {
       $102 = HEAP32[(55184)>>2]|0;
       $103 = (($102) + ($$1345))|0;
       HEAP32[(55184)>>2] = $103;
       HEAP32[(55196)>>2] = $$1;
       $104 = $103 | 1;
       $105 = ((($$1)) + 4|0);
       HEAP32[$105>>2] = $104;
       $106 = HEAP32[(55192)>>2]|0;
       $107 = ($$1|0)==($106|0);
       if (!($107)) {
        break;
       }
       HEAP32[(55192)>>2] = 0;
       HEAP32[(55180)>>2] = 0;
       break;
      }
      $108 = HEAP32[(55192)>>2]|0;
      $109 = ($108|0)==($12|0);
      if ($109) {
       $110 = HEAP32[(55180)>>2]|0;
       $111 = (($110) + ($$1345))|0;
       HEAP32[(55180)>>2] = $111;
       HEAP32[(55192)>>2] = $92;
       $112 = $111 | 1;
       $113 = ((($$1)) + 4|0);
       HEAP32[$113>>2] = $112;
       $114 = (($92) + ($111)|0);
       HEAP32[$114>>2] = $111;
       break;
      }
      $115 = $95 & -8;
      $116 = (($115) + ($$1345))|0;
      $117 = $95 >>> 3;
      $118 = ($95>>>0)<(256);
      do {
       if ($118) {
        $119 = ((($12)) + 8|0);
        $120 = HEAP32[$119>>2]|0;
        $121 = ((($12)) + 12|0);
        $122 = HEAP32[$121>>2]|0;
        $123 = ($122|0)==($120|0);
        if ($123) {
         $124 = 1 << $117;
         $125 = $124 ^ -1;
         $126 = HEAP32[13793]|0;
         $127 = $126 & $125;
         HEAP32[13793] = $127;
         break;
        } else {
         $128 = ((($120)) + 12|0);
         HEAP32[$128>>2] = $122;
         $129 = ((($122)) + 8|0);
         HEAP32[$129>>2] = $120;
         break;
        }
       } else {
        $130 = ((($12)) + 24|0);
        $131 = HEAP32[$130>>2]|0;
        $132 = ((($12)) + 12|0);
        $133 = HEAP32[$132>>2]|0;
        $134 = ($133|0)==($12|0);
        do {
         if ($134) {
          $139 = ((($12)) + 16|0);
          $140 = ((($139)) + 4|0);
          $141 = HEAP32[$140>>2]|0;
          $142 = ($141|0)==(0|0);
          if ($142) {
           $143 = HEAP32[$139>>2]|0;
           $144 = ($143|0)==(0|0);
           if ($144) {
            $$3363 = 0;
            break;
           } else {
            $$1361$ph = $143;$$1365$ph = $139;
           }
          } else {
           $$1361$ph = $141;$$1365$ph = $140;
          }
          $$1361 = $$1361$ph;$$1365 = $$1365$ph;
          while(1) {
           $145 = ((($$1361)) + 20|0);
           $146 = HEAP32[$145>>2]|0;
           $147 = ($146|0)==(0|0);
           if ($147) {
            $148 = ((($$1361)) + 16|0);
            $149 = HEAP32[$148>>2]|0;
            $150 = ($149|0)==(0|0);
            if ($150) {
             break;
            } else {
             $$1361$be = $149;$$1365$be = $148;
            }
           } else {
            $$1361$be = $146;$$1365$be = $145;
           }
           $$1361 = $$1361$be;$$1365 = $$1365$be;
          }
          HEAP32[$$1365>>2] = 0;
          $$3363 = $$1361;
         } else {
          $135 = ((($12)) + 8|0);
          $136 = HEAP32[$135>>2]|0;
          $137 = ((($136)) + 12|0);
          HEAP32[$137>>2] = $133;
          $138 = ((($133)) + 8|0);
          HEAP32[$138>>2] = $136;
          $$3363 = $133;
         }
        } while(0);
        $151 = ($131|0)==(0|0);
        if (!($151)) {
         $152 = ((($12)) + 28|0);
         $153 = HEAP32[$152>>2]|0;
         $154 = (55476 + ($153<<2)|0);
         $155 = HEAP32[$154>>2]|0;
         $156 = ($155|0)==($12|0);
         if ($156) {
          HEAP32[$154>>2] = $$3363;
          $cond372 = ($$3363|0)==(0|0);
          if ($cond372) {
           $157 = 1 << $153;
           $158 = $157 ^ -1;
           $159 = HEAP32[(55176)>>2]|0;
           $160 = $159 & $158;
           HEAP32[(55176)>>2] = $160;
           break;
          }
         } else {
          $161 = ((($131)) + 16|0);
          $162 = HEAP32[$161>>2]|0;
          $163 = ($162|0)==($12|0);
          $164 = ((($131)) + 20|0);
          $$sink395 = $163 ? $161 : $164;
          HEAP32[$$sink395>>2] = $$3363;
          $165 = ($$3363|0)==(0|0);
          if ($165) {
           break;
          }
         }
         $166 = ((($$3363)) + 24|0);
         HEAP32[$166>>2] = $131;
         $167 = ((($12)) + 16|0);
         $168 = HEAP32[$167>>2]|0;
         $169 = ($168|0)==(0|0);
         if (!($169)) {
          $170 = ((($$3363)) + 16|0);
          HEAP32[$170>>2] = $168;
          $171 = ((($168)) + 24|0);
          HEAP32[$171>>2] = $$3363;
         }
         $172 = ((($167)) + 4|0);
         $173 = HEAP32[$172>>2]|0;
         $174 = ($173|0)==(0|0);
         if (!($174)) {
          $175 = ((($$3363)) + 20|0);
          HEAP32[$175>>2] = $173;
          $176 = ((($173)) + 24|0);
          HEAP32[$176>>2] = $$3363;
         }
        }
       }
      } while(0);
      $177 = $116 | 1;
      $178 = ((($$1)) + 4|0);
      HEAP32[$178>>2] = $177;
      $179 = (($92) + ($116)|0);
      HEAP32[$179>>2] = $116;
      $180 = HEAP32[(55192)>>2]|0;
      $181 = ($$1|0)==($180|0);
      if ($181) {
       HEAP32[(55180)>>2] = $116;
       break;
      } else {
       $$2 = $116;
      }
     } else {
      $182 = $95 & -2;
      HEAP32[$94>>2] = $182;
      $183 = $$1345 | 1;
      $184 = ((($$1)) + 4|0);
      HEAP32[$184>>2] = $183;
      $185 = (($92) + ($$1345)|0);
      HEAP32[$185>>2] = $$1345;
      $$2 = $$1345;
     }
     $186 = $$2 >>> 3;
     $187 = ($$2>>>0)<(256);
     if ($187) {
      $188 = $186 << 1;
      $189 = (55212 + ($188<<2)|0);
      $190 = HEAP32[13793]|0;
      $191 = 1 << $186;
      $192 = $190 & $191;
      $193 = ($192|0)==(0);
      if ($193) {
       $194 = $190 | $191;
       HEAP32[13793] = $194;
       $$pre = ((($189)) + 8|0);
       $$0366 = $189;$$pre$phiZ2D = $$pre;
      } else {
       $195 = ((($189)) + 8|0);
       $196 = HEAP32[$195>>2]|0;
       $$0366 = $196;$$pre$phiZ2D = $195;
      }
      HEAP32[$$pre$phiZ2D>>2] = $$1;
      $197 = ((($$0366)) + 12|0);
      HEAP32[$197>>2] = $$1;
      $198 = ((($$1)) + 8|0);
      HEAP32[$198>>2] = $$0366;
      $199 = ((($$1)) + 12|0);
      HEAP32[$199>>2] = $189;
      break;
     }
     $200 = $$2 >>> 8;
     $201 = ($200|0)==(0);
     if ($201) {
      $$0359 = 0;
     } else {
      $202 = ($$2>>>0)>(16777215);
      if ($202) {
       $$0359 = 31;
      } else {
       $203 = (($200) + 1048320)|0;
       $204 = $203 >>> 16;
       $205 = $204 & 8;
       $206 = $200 << $205;
       $207 = (($206) + 520192)|0;
       $208 = $207 >>> 16;
       $209 = $208 & 4;
       $210 = $209 | $205;
       $211 = $206 << $209;
       $212 = (($211) + 245760)|0;
       $213 = $212 >>> 16;
       $214 = $213 & 2;
       $215 = $210 | $214;
       $216 = (14 - ($215))|0;
       $217 = $211 << $214;
       $218 = $217 >>> 15;
       $219 = (($216) + ($218))|0;
       $220 = $219 << 1;
       $221 = (($219) + 7)|0;
       $222 = $$2 >>> $221;
       $223 = $222 & 1;
       $224 = $223 | $220;
       $$0359 = $224;
      }
     }
     $225 = (55476 + ($$0359<<2)|0);
     $226 = ((($$1)) + 28|0);
     HEAP32[$226>>2] = $$0359;
     $227 = ((($$1)) + 16|0);
     $228 = ((($$1)) + 20|0);
     HEAP32[$228>>2] = 0;
     HEAP32[$227>>2] = 0;
     $229 = HEAP32[(55176)>>2]|0;
     $230 = 1 << $$0359;
     $231 = $229 & $230;
     $232 = ($231|0)==(0);
     L102: do {
      if ($232) {
       $233 = $229 | $230;
       HEAP32[(55176)>>2] = $233;
       HEAP32[$225>>2] = $$1;
       $234 = ((($$1)) + 24|0);
       HEAP32[$234>>2] = $225;
       $235 = ((($$1)) + 12|0);
       HEAP32[$235>>2] = $$1;
       $236 = ((($$1)) + 8|0);
       HEAP32[$236>>2] = $$1;
      } else {
       $237 = HEAP32[$225>>2]|0;
       $238 = ((($237)) + 4|0);
       $239 = HEAP32[$238>>2]|0;
       $240 = $239 & -8;
       $241 = ($240|0)==($$2|0);
       L105: do {
        if ($241) {
         $$0347$lcssa = $237;
        } else {
         $242 = ($$0359|0)==(31);
         $243 = $$0359 >>> 1;
         $244 = (25 - ($243))|0;
         $245 = $242 ? 0 : $244;
         $246 = $$2 << $245;
         $$0346381 = $246;$$0347380 = $237;
         while(1) {
          $253 = $$0346381 >>> 31;
          $254 = (((($$0347380)) + 16|0) + ($253<<2)|0);
          $249 = HEAP32[$254>>2]|0;
          $255 = ($249|0)==(0|0);
          if ($255) {
           break;
          }
          $247 = $$0346381 << 1;
          $248 = ((($249)) + 4|0);
          $250 = HEAP32[$248>>2]|0;
          $251 = $250 & -8;
          $252 = ($251|0)==($$2|0);
          if ($252) {
           $$0347$lcssa = $249;
           break L105;
          } else {
           $$0346381 = $247;$$0347380 = $249;
          }
         }
         HEAP32[$254>>2] = $$1;
         $256 = ((($$1)) + 24|0);
         HEAP32[$256>>2] = $$0347380;
         $257 = ((($$1)) + 12|0);
         HEAP32[$257>>2] = $$1;
         $258 = ((($$1)) + 8|0);
         HEAP32[$258>>2] = $$1;
         break L102;
        }
       } while(0);
       $259 = ((($$0347$lcssa)) + 8|0);
       $260 = HEAP32[$259>>2]|0;
       $261 = ((($260)) + 12|0);
       HEAP32[$261>>2] = $$1;
       HEAP32[$259>>2] = $$1;
       $262 = ((($$1)) + 8|0);
       HEAP32[$262>>2] = $260;
       $263 = ((($$1)) + 12|0);
       HEAP32[$263>>2] = $$0347$lcssa;
       $264 = ((($$1)) + 24|0);
       HEAP32[$264>>2] = 0;
      }
     } while(0);
     $265 = HEAP32[(55204)>>2]|0;
     $266 = (($265) + -1)|0;
     HEAP32[(55204)>>2] = $266;
     $267 = ($266|0)==(0);
     if ($267) {
      $$0194$in$i = (55656);
      while(1) {
       $$0194$i = HEAP32[$$0194$in$i>>2]|0;
       $268 = ($$0194$i|0)==(0|0);
       $269 = ((($$0194$i)) + 8|0);
       if ($268) {
        break;
       } else {
        $$0194$in$i = $269;
       }
      }
      HEAP32[(55204)>>2] = -1;
     }
    }
   }
  }
 } while(0);
 $270 = HEAP32[(55616)>>2]|0;
 $271 = $270 & 2;
 $272 = ($271|0)==(0);
 if ($272) {
  return;
 }
 (___pthread_mutex_unlock((55620))|0);
 return;
}
function _sbrk(increment) {
    increment = increment|0;
    var oldDynamicTop = 0;
    var oldDynamicTopOnChange = 0;
    var newDynamicTop = 0;
    var totalMemory = 0;
    totalMemory = getTotalMemory()|0;

    // Perform a compare-and-swap loop to update the new dynamic top value. This is because
    // this function can becalled simultaneously in multiple threads.
    do {
      oldDynamicTop = Atomics_load(HEAP32, DYNAMICTOP_PTR>>2)|0;
      newDynamicTop = oldDynamicTop + increment | 0;
      // Asking to increase dynamic top to a too high value? In pthreads builds we cannot
      // enlarge memory, so this needs to fail.
      if (((increment|0) > 0 & (newDynamicTop|0) < (oldDynamicTop|0)) // Detect and fail if we would wrap around signed 32-bit int.
        | (newDynamicTop|0) < 0 // Also underflow, sbrk() should be able to be used to subtract.
        | (newDynamicTop|0) > (totalMemory|0)) {
        abortOnCannotGrowMemory()|0;
      }
      // Attempt to update the dynamic top to new value. Another thread may have beat this thread to the update,
      // in which case we will need to start over by iterating the loop body again.
      oldDynamicTopOnChange = Atomics_compareExchange(HEAP32, DYNAMICTOP_PTR>>2, oldDynamicTop|0, newDynamicTop|0)|0;
    } while((oldDynamicTopOnChange|0) != (oldDynamicTop|0));
    return oldDynamicTop|0;
}
function ___pthread_mutex_lock($0) {
 $0 = $0|0;
 var $$0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $1 = HEAP32[$0>>2]|0;
 $2 = $1 & 15;
 $3 = ($2|0)==(0);
 if ($3) {
  $4 = ((($0)) + 4|0);
  $5 = (Atomics_compareExchange(HEAP32, $4>>2,0,16)|0);
  $6 = ($5|0)==(0);
  if ($6) {
   $$0 = 0;
   return ($$0|0);
  }
 }
 $7 = (___pthread_mutex_timedlock($0,0)|0);
 $$0 = $7;
 return ($$0|0);
}
function ___pthread_mutex_unlock($0) {
 $0 = $0|0;
 var $$0 = 0, $$045 = 0, $$pre = 0, $$pre$phiZ2D = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0;
 var $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0, $6 = 0;
 var $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, $or$cond3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $1 = ((($0)) + 8|0);
 $2 = (Atomics_load(HEAP32,$1>>2)|0);
 $3 = HEAP32[$0>>2]|0;
 $4 = $3 & 15;
 $5 = $3 & 128;
 $6 = $5 ^ 128;
 $7 = ($4|0)==(0);
 if ($7) {
  $$pre = ((($0)) + 4|0);
  $$045 = 0;$$pre$phiZ2D = $$pre;
 } else {
  $8 = (_pthread_self()|0);
  $9 = ((($0)) + 4|0);
  $10 = (Atomics_load(HEAP32,$9>>2)|0);
  $11 = $10 & 2147483647;
  $12 = ((($8)) + 52|0);
  $13 = HEAP32[$12>>2]|0;
  $14 = ($11|0)==($13|0);
  if (!($14)) {
   $$0 = 1;
   return ($$0|0);
  }
  $15 = $3 & 3;
  $16 = ($15|0)==(1);
  if ($16) {
   $17 = ((($0)) + 20|0);
   $18 = HEAP32[$17>>2]|0;
   $19 = ($18|0)==(0);
   if (!($19)) {
    $20 = (($18) + -1)|0;
    HEAP32[$17>>2] = $20;
    $$0 = 0;
    return ($$0|0);
   }
  }
  $21 = ($6|0)==(0);
  $22 = ((($0)) + 16|0);
  if ($21) {
   $23 = ((($8)) + 176|0);
   Atomics_store(HEAP32,$23>>2,$22)|0;
   ___vm_lock();
  }
  $24 = ((($0)) + 12|0);
  $25 = HEAP32[$24>>2]|0;
  $26 = HEAP32[$22>>2]|0;
  Atomics_store(HEAP32,$25>>2,$26)|0;
  $27 = ((($8)) + 168|0);
  $28 = ($26|0)==($27|0);
  if ($28) {
   $$045 = $8;$$pre$phiZ2D = $9;
  } else {
   $29 = ((($26)) + -4|0);
   Atomics_store(HEAP32,$29>>2,$25)|0;
   $$045 = $8;$$pre$phiZ2D = $9;
  }
 }
 $30 = $3 & 8;
 $31 = ($30|0)==(0);
 $32 = $31 ? 0 : 2147483647;
 while(1) {
  $33 = (Atomics_load(HEAP32, $$pre$phiZ2D>>2)|0);
  $34 = (Atomics_compareExchange(HEAP32, $$pre$phiZ2D>>2,$33,$32)|0);
  $35 = ($34|0)==($33|0);
  if ($35) {
   break;
  }
 }
 $36 = ($6|0)!=(0);
 $or$cond = $7 | $36;
 if (!($or$cond)) {
  $37 = ((($$045)) + 176|0);
  Atomics_store(HEAP32,$37>>2,0)|0;
  ___vm_unlock();
 }
 $38 = ($2|0)!=(0);
 $39 = ($33|0)<(0);
 $or$cond3 = $38 | $39;
 if (!($or$cond3)) {
  $$0 = 0;
  return ($$0|0);
 }
 (_emscripten_futex_wake(($$pre$phiZ2D|0),1)|0);
 $$0 = 0;
 return ($$0|0);
}
var Fetch = {
  attr_t_offset_requestMethod: 0,
  attr_t_offset_userData: 32,
  attr_t_offset_onsuccess: 36,
  attr_t_offset_onerror: 40,
  attr_t_offset_onprogress: 44,
  attr_t_offset_attributes: 48,
  attr_t_offset_timeoutMSecs: 52,
  attr_t_offset_withCredentials: 56,
  attr_t_offset_destinationPath: 60,
  attr_t_offset_userName: 64,
  attr_t_offset_password: 68,
  attr_t_offset_requestHeaders: 72,
  attr_t_offset_overriddenMimeType: 76,
  attr_t_offset_requestData: 80,
  attr_t_offset_requestDataSize: 84,

  fetch_t_offset_id: 0,
  fetch_t_offset_userData: 4,
  fetch_t_offset_url: 8,
  fetch_t_offset_data: 12,
  fetch_t_offset_numBytes: 16,
  fetch_t_offset_dataOffset: 24,
  fetch_t_offset_totalBytes: 32,
  fetch_t_offset_readyState: 40,
  fetch_t_offset_status: 42,
  fetch_t_offset_statusText: 44,
  fetch_t_offset___proxyState: 108,
  fetch_t_offset___attributes: 112,

  xhrs: [],
  // The web worker that runs proxied file I/O requests.
  worker: undefined,
  // Specifies an instance to the IndexedDB database. The database is opened
  // as a preload step before the Emscripten application starts.
  dbInstance: undefined,

  setu64: function(addr, val) {
    HEAPU32[addr >> 2] = val;
    HEAPU32[addr + 4 >> 2] = (val / 4294967296)|0;
  },

  openDatabase: function(dbname, dbversion, onsuccess, onerror) {
    try {

      console.log('fetch: indexedDB.open(dbname="' + dbname + '", dbversion="' + dbversion + '");');

      var openRequest = indexedDB.open(dbname, dbversion);
    } catch (e) { return onerror(e); }

    openRequest.onupgradeneeded = function(event) {

      console.log('fetch: IndexedDB upgrade needed. Clearing database.');

      var db = event.target.result;
      if (db.objectStoreNames.contains('FILES')) {
        db.deleteObjectStore('FILES');
      }
      db.createObjectStore('FILES');
    };
    openRequest.onsuccess = function(event) { onsuccess(event.target.result); };
    openRequest.onerror = function(error) { onerror(error); };
  },

  initFetchWorker: function() {
    var stackSize = 128*1024;
    var stack = allocate(stackSize>>2, "i32*", ALLOC_DYNAMIC);
    Fetch.worker.postMessage({cmd: 'init', TOTAL_MEMORY: TOTAL_MEMORY, DYNAMICTOP_PTR: DYNAMICTOP_PTR, STACKTOP: stack, STACK_MAX: stack + stackSize, queuePtr: _fetch_work_queue, buffer: HEAPU8.buffer});
  },

  staticInit: function() {



    var isMainThread = (typeof ENVIRONMENT_IS_FETCH_WORKER === 'undefined');


    var onsuccess = function(db) {

      console.log('fetch: IndexedDB successfully opened.');

      Fetch.dbInstance = db;

      if (isMainThread) {



        removeRunDependency('library_fetch_init');
      }
    };
    var onerror = function() {

      console.error('fetch: IndexedDB open failed.');

      Fetch.dbInstance = false;

      if (isMainThread) {



        removeRunDependency('library_fetch_init');
      }
    };
    Fetch.openDatabase('emscripten_filesystem', 1, onsuccess, onerror);
    if (typeof ENVIRONMENT_IS_FETCH_WORKER === 'undefined' || !ENVIRONMENT_IS_FETCH_WORKER) addRunDependency('library_fetch_init');

  }
}

function __emscripten_fetch_delete_cached_data(db, fetch, onsuccess, onerror) {
  if (!db) {

    console.error('fetch: IndexedDB not available!');

    onerror(fetch, 0, 'IndexedDB not available!');
    return;
  }

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var path = HEAPU32[fetch_attr + Fetch.attr_t_offset_destinationPath >> 2];
  if (!path) path = HEAPU32[fetch + Fetch.fetch_t_offset_url >> 2];
  var pathStr = Pointer_stringify(path);

  try {
    var transaction = db.transaction(['FILES'], 'readwrite');
    var packages = transaction.objectStore('FILES');
    var request = packages.delete(pathStr);
    request.onsuccess = function(event) {
      var value = event.target.result;

      console.log('fetch: Deleted file ' + pathStr + ' from IndexedDB');

      HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = 0;
      Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, 0);
      Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
      Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
      stringToUTF8("OK", fetch + Fetch.fetch_t_offset_statusText, 64);
      onsuccess(fetch, 0, value);
    };
    request.onerror = function(error) {

      console.error('fetch: Failed to delete file ' + pathStr + ' from IndexedDB! error: ' + error);

      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
      stringToUTF8("Not Found", fetch + Fetch.fetch_t_offset_statusText, 64);
      onerror(fetch, 0, error);
    };
  } catch(e) {

    console.error('fetch: Failed to load file ' + pathStr + ' from IndexedDB! Got exception ' + e);

    onerror(fetch, 0, e);
  }
}

function __emscripten_fetch_load_cached_data(db, fetch, onsuccess, onerror) {
  if (!db) {

    console.error('fetch: IndexedDB not available!');

    onerror(fetch, 0, 'IndexedDB not available!');
    return;
  }

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var path = HEAPU32[fetch_attr + Fetch.attr_t_offset_destinationPath >> 2];
  if (!path) path = HEAPU32[fetch + Fetch.fetch_t_offset_url >> 2];
  var pathStr = Pointer_stringify(path);

  try {
    var transaction = db.transaction(['FILES'], 'readonly');
    var packages = transaction.objectStore('FILES');
    var getRequest = packages.get(pathStr);
    getRequest.onsuccess = function(event) {
      if (event.target.result) {
        var value = event.target.result;
        var len = value.byteLength || value.length;

        console.log('fetch: Loaded file ' + pathStr + ' from IndexedDB, length: ' + len);


        // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
        // freed when emscripten_fetch_close() is called.
        var ptr = _malloc(len);
        HEAPU8.set(new Uint8Array(value), ptr);
        HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = ptr;
        Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, len);
        Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
        Fetch.setu64(fetch + Fetch.fetch_t_offset_totalBytes, len);
        HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
        HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
        stringToUTF8("OK", fetch + Fetch.fetch_t_offset_statusText, 64);
        onsuccess(fetch, 0, value);
      } else {
        // Succeeded to load, but the load came back with the value of undefined, treat that as an error since we never store undefined in db.

        console.error('fetch: File ' + pathStr + ' not found in IndexedDB');

        HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
        HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
        stringToUTF8("Not Found", fetch + Fetch.fetch_t_offset_statusText, 64);
        onerror(fetch, 0, 'no data');
      }
    };
    getRequest.onerror = function(error) {

      console.error('fetch: Failed to load file ' + pathStr + ' from IndexedDB!');

      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 404; // Mimic XHR HTTP status code 404 "Not Found"
      stringToUTF8("Not Found", fetch + Fetch.fetch_t_offset_statusText, 64);
      onerror(fetch, 0, error);
    };
  } catch(e) {

    console.error('fetch: Failed to load file ' + pathStr + ' from IndexedDB! Got exception ' + e);

    onerror(fetch, 0, e);
  }
}

function __emscripten_fetch_cache_data(db, fetch, data, onsuccess, onerror) {
  if (!db) {

    console.error('fetch: IndexedDB not available!');

    onerror(fetch, 0, 'IndexedDB not available!');
    return;
  }

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var destinationPath = HEAPU32[fetch_attr + Fetch.attr_t_offset_destinationPath >> 2];
  if (!destinationPath) destinationPath = HEAPU32[fetch + Fetch.fetch_t_offset_url >> 2];
  var destinationPathStr = Pointer_stringify(destinationPath);

  try {
    var transaction = db.transaction(['FILES'], 'readwrite');
    var packages = transaction.objectStore('FILES');
    var putRequest = packages.put(data, destinationPathStr);
    putRequest.onsuccess = function(event) {

      console.log('fetch: Stored file "' + destinationPathStr + '" to IndexedDB cache.');

      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 200; // Mimic XHR HTTP status code 200 "OK"
      stringToUTF8("OK", fetch + Fetch.fetch_t_offset_statusText, 64);
      onsuccess(fetch, 0, destinationPathStr);
    };
    putRequest.onerror = function(error) {

      console.error('fetch: Failed to store file "' + destinationPathStr + '" to IndexedDB cache!');

      // Most likely we got an error if IndexedDB is unwilling to store any more data for this page.
      // TODO: Can we identify and break down different IndexedDB-provided errors and convert those
      // to more HTTP status codes for more information?
      HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = 4; // Mimic XHR readyState 4 === 'DONE: The operation is complete'
      HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = 413; // Mimic XHR HTTP status code 413 "Payload Too Large"
      stringToUTF8("Payload Too Large", fetch + Fetch.fetch_t_offset_statusText, 64);
      onerror(fetch, 0, error);
    };
  } catch(e) {

      console.error('fetch: Failed to store file "' + destinationPathStr + '" to IndexedDB cache! Exception: ' + e);

    onerror(fetch, 0, e);
  }
}

function __emscripten_fetch_xhr(fetch, onsuccess, onerror, onprogress) {
  var url = HEAPU32[fetch + Fetch.fetch_t_offset_url >> 2];
  if (!url) {

    console.error('fetch: XHR failed, no URL specified!');

    onerror(fetch, 0, 'no url specified!');
    return;
  }
  var url_ = Pointer_stringify(url);

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var requestMethod = Pointer_stringify(fetch_attr);
  if (!requestMethod) requestMethod = 'GET';
  var userData = HEAPU32[fetch_attr + Fetch.attr_t_offset_userData >> 2];
  var fetchAttributes = HEAPU32[fetch_attr + Fetch.attr_t_offset_attributes >> 2];
  var timeoutMsecs = HEAPU32[fetch_attr + Fetch.attr_t_offset_timeoutMSecs >> 2];
  var withCredentials = !!HEAPU32[fetch_attr + Fetch.attr_t_offset_withCredentials >> 2];
  var destinationPath = HEAPU32[fetch_attr + Fetch.attr_t_offset_destinationPath >> 2];
  var userName = HEAPU32[fetch_attr + Fetch.attr_t_offset_userName >> 2];
  var password = HEAPU32[fetch_attr + Fetch.attr_t_offset_password >> 2];
  var requestHeaders = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestHeaders >> 2];
  var overriddenMimeType = HEAPU32[fetch_attr + Fetch.attr_t_offset_overriddenMimeType >> 2];
  var dataPtr = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestData >> 2];
  var dataLength = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestDataSize >> 2];

  var fetchAttrLoadToMemory = !!(fetchAttributes & 1/*EMSCRIPTEN_FETCH_LOAD_TO_MEMORY*/);
  var fetchAttrStreamData = !!(fetchAttributes & 2/*EMSCRIPTEN_FETCH_STREAM_DATA*/);
  var fetchAttrPersistFile = !!(fetchAttributes & 4/*EMSCRIPTEN_FETCH_PERSIST_FILE*/);
  var fetchAttrAppend = !!(fetchAttributes & 8/*EMSCRIPTEN_FETCH_APPEND*/);
  var fetchAttrReplace = !!(fetchAttributes & 16/*EMSCRIPTEN_FETCH_REPLACE*/);
  var fetchAttrNoDownload = !!(fetchAttributes & 32/*EMSCRIPTEN_FETCH_NO_DOWNLOAD*/);
  var fetchAttrSynchronous = !!(fetchAttributes & 64/*EMSCRIPTEN_FETCH_SYNCHRONOUS*/);
  var fetchAttrWaitable = !!(fetchAttributes & 128/*EMSCRIPTEN_FETCH_WAITABLE*/);

  var userNameStr = userName ? Pointer_stringify(userName) : undefined;
  var passwordStr = password ? Pointer_stringify(password) : undefined;
  var overriddenMimeTypeStr = overriddenMimeType ? Pointer_stringify(overriddenMimeType) : undefined;

  var xhr = new XMLHttpRequest();
  xhr.withCredentials = withCredentials;

  console.log('fetch: xhr.timeout: ' + xhr.timeout + ', xhr.withCredentials: ' + xhr.withCredentials);
  console.log('fetch: xhr.open(requestMethod="' + requestMethod + '", url: "' + url_ +'", userName: ' + userNameStr + ', password: ' + passwordStr + ');');

  xhr.open(requestMethod, url_, !fetchAttrSynchronous, userNameStr, passwordStr);
  if (!fetchAttrSynchronous) xhr.timeout = timeoutMsecs; // XHR timeout field is only accessible in async XHRs, and must be set after .open() but before .send().
  xhr.url_ = url_; // Save the url for debugging purposes (and for comparing to the responseURL that server side advertised)
  xhr.responseType = fetchAttrStreamData ? 'moz-chunked-arraybuffer' : 'arraybuffer';

  if (overriddenMimeType) {

    console.log('fetch: xhr.overrideMimeType("' + overriddenMimeTypeStr + '");');

    xhr.overrideMimeType(overriddenMimeTypeStr);
  }
  if (requestHeaders) {
    for(;;) {
      var key = HEAPU32[requestHeaders >> 2];
      if (!key) break;
      var value = HEAPU32[requestHeaders + 4 >> 2];
      if (!value) break;
      requestHeaders += 8;
      var keyStr = Pointer_stringify(key);
      var valueStr = Pointer_stringify(value);

      console.log('fetch: xhr.setRequestHeader("' + keyStr + '", "' + valueStr + '");');

      xhr.setRequestHeader(keyStr, valueStr);
    }
  }
  Fetch.xhrs.push(xhr);
  var id = Fetch.xhrs.length;
  HEAPU32[fetch + Fetch.fetch_t_offset_id >> 2] = id;
  var data = (dataPtr && dataLength) ? HEAPU8.slice(dataPtr, dataPtr + dataLength) : null;
  // TODO: Support specifying custom headers to the request.

  xhr.onload = function(e) {
    var len = xhr.response ? xhr.response.byteLength : 0;
    var ptr = 0;
    var ptrLen = 0;
    if (fetchAttrLoadToMemory && !fetchAttrStreamData) {
      ptrLen = len;

      console.log('fetch: allocating ' + ptrLen + ' bytes in Emscripten heap for xhr data');

      // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
      // freed when emscripten_fetch_close() is called.
      ptr = _malloc(ptrLen);
      HEAPU8.set(new Uint8Array(xhr.response), ptr);
    }
    HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = ptr;
    Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, ptrLen);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
    if (len) {
      // If the final XHR.onload handler receives the bytedata to compute total length, report that,
      // otherwise don't write anything out here, which will retain the latest byte size reported in
      // the most recent XHR.onprogress handler.
      Fetch.setu64(fetch + Fetch.fetch_t_offset_totalBytes, len);
    }
    HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = xhr.readyState;
    if (xhr.readyState === 4 && xhr.status === 0) {
      if (len > 0) xhr.status = 200; // If loading files from a source that does not give HTTP status code, assume success if we got data bytes.
      else xhr.status = 404; // Conversely, no data bytes is 404.
    }
    HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = xhr.status;
    if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + Fetch.fetch_t_offset_statusText, 64);
    if (xhr.status == 200) {

      console.log('fetch: xhr of URL "' + xhr.url_ + '" / responseURL "' + xhr.responseURL + '" succeeded with status 200');

      if (onsuccess) onsuccess(fetch, xhr, e);
    } else {

      console.error('fetch: xhr of URL "' + xhr.url_ + '" / responseURL "' + xhr.responseURL + '" failed with status ' + xhr.status);

      if (onerror) onerror(fetch, xhr, e);
    }
  }
  xhr.onerror = function(e) {
    var status = xhr.status; // XXX TODO: Overwriting xhr.status doesn't work here, so don't override anywhere else either.
    if (xhr.readyState == 4 && status == 0) status = 404; // If no error recorded, pretend it was 404 Not Found.

    console.error('fetch: xhr of URL "' + xhr.url_ + '" / responseURL "' + xhr.responseURL + '" finished with error, readyState ' + xhr.readyState + ' and status ' + status);

    HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = 0;
    Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, 0);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, 0);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_totalBytes, 0);
    HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = xhr.readyState;
    HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = status;
    if (onerror) onerror(fetch, xhr, e);
  }
  xhr.ontimeout = function(e) {

    console.error('fetch: xhr of URL "' + xhr.url_ + '" / responseURL "' + xhr.responseURL + '" timed out, readyState ' + xhr.readyState + ' and status ' + xhr.status);

    if (onerror) onerror(fetch, xhr, e);
  }
  xhr.onprogress = function(e) {
    var ptrLen = (fetchAttrLoadToMemory && fetchAttrStreamData && xhr.response) ? xhr.response.byteLength : 0;
    var ptr = 0;
    if (fetchAttrLoadToMemory && fetchAttrStreamData) {

      console.log('fetch: allocating ' + ptrLen + ' bytes in Emscripten heap for xhr data');

      // The data pointer malloc()ed here has the same lifetime as the emscripten_fetch_t structure itself has, and is
      // freed when emscripten_fetch_close() is called.
      ptr = _malloc(ptrLen);
      HEAPU8.set(new Uint8Array(xhr.response), ptr);
    }
    HEAPU32[fetch + Fetch.fetch_t_offset_data >> 2] = ptr;
    Fetch.setu64(fetch + Fetch.fetch_t_offset_numBytes, ptrLen);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_dataOffset, e.loaded - ptrLen);
    Fetch.setu64(fetch + Fetch.fetch_t_offset_totalBytes, e.total);
    HEAPU16[fetch + Fetch.fetch_t_offset_readyState >> 1] = xhr.readyState;
    if (xhr.readyState >= 3 && xhr.status === 0 && e.loaded > 0) xhr.status = 200; // If loading files from a source that does not give HTTP status code, assume success if we get data bytes
    HEAPU16[fetch + Fetch.fetch_t_offset_status >> 1] = xhr.status;
    if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + Fetch.fetch_t_offset_statusText, 64);
    if (onprogress) onprogress(fetch, xhr, e);
  }

  console.log('fetch: xhr.send(data=' + data + ')');

  try {
    xhr.send(data);
  } catch(e) {

    console.error('fetch: xhr failed with exception: ' + e);

    if (onerror) onerror(fetch, xhr, e);
  }
}

function emscripten_start_fetch(fetch, successcb, errorcb, progresscb) {
  if (typeof Module !== 'undefined') Module['noExitRuntime'] = true; // If we are the main Emscripten runtime, we should not be closing down.

  var fetch_attr = fetch + Fetch.fetch_t_offset___attributes;
  var requestMethod = Pointer_stringify(fetch_attr);
  var onsuccess = HEAPU32[fetch_attr + Fetch.attr_t_offset_onsuccess >> 2];
  var onerror = HEAPU32[fetch_attr + Fetch.attr_t_offset_onerror >> 2];
  var onprogress = HEAPU32[fetch_attr + Fetch.attr_t_offset_onprogress >> 2];
  var fetchAttributes = HEAPU32[fetch_attr + Fetch.attr_t_offset_attributes >> 2];
  var fetchAttrLoadToMemory = !!(fetchAttributes & 1/*EMSCRIPTEN_FETCH_LOAD_TO_MEMORY*/);
  var fetchAttrStreamData = !!(fetchAttributes & 2/*EMSCRIPTEN_FETCH_STREAM_DATA*/);
  var fetchAttrPersistFile = !!(fetchAttributes & 4/*EMSCRIPTEN_FETCH_PERSIST_FILE*/);
  var fetchAttrAppend = !!(fetchAttributes & 8/*EMSCRIPTEN_FETCH_APPEND*/);
  var fetchAttrReplace = !!(fetchAttributes & 16/*EMSCRIPTEN_FETCH_REPLACE*/);
  var fetchAttrNoDownload = !!(fetchAttributes & 32/*EMSCRIPTEN_FETCH_NO_DOWNLOAD*/);

  var reportSuccess = function(fetch, xhr, e) {

    console.log('fetch: operation success. e: ' + e);

    if (onsuccess && typeof dynCall === 'function') Module['dynCall_vi'](onsuccess, fetch);
    else if (successcb) successcb(fetch);
  };

  var cacheResultAndReportSuccess = function(fetch, xhr, e) {

    console.log('fetch: operation success. Caching result.. e: ' + e);

    var storeSuccess = function(fetch, xhr, e) {

      console.log('fetch: IndexedDB store succeeded.');

      if (onsuccess && typeof dynCall === 'function') Module['dynCall_vi'](onsuccess, fetch);
      else if (successcb) successcb(fetch);
    };
    var storeError = function(fetch, xhr, e) {

      console.error('fetch: IndexedDB store failed.');

      if (onsuccess && typeof dynCall === 'function') Module['dynCall_vi'](onsuccess, fetch);
      else if (successcb) successcb(fetch);
    };
    __emscripten_fetch_cache_data(Fetch.dbInstance, fetch, xhr.response, storeSuccess, storeError);
  };

  var reportProgress = function(fetch, xhr, e) {
    if (onprogress && typeof dynCall === 'function') Module['dynCall_vi'](onprogress, fetch);
    else if (progresscb) progresscb(fetch);
  };

  var reportError = function(fetch, xhr, e) {

    console.error('fetch: operation failed: ' + e);

    if (onerror && typeof dynCall === 'function') Module['dynCall_vi'](onerror, fetch);
    else if (errorcb) errorcb(fetch);
  };

  var performUncachedXhr = function(fetch, xhr, e) {

    console.error('fetch: starting (uncached) XHR: ' + e);

    __emscripten_fetch_xhr(fetch, reportSuccess, reportError, reportProgress);
  };

  var performCachedXhr = function(fetch, xhr, e) {

    console.error('fetch: starting (cached) XHR: ' + e);

    __emscripten_fetch_xhr(fetch, cacheResultAndReportSuccess, reportError, reportProgress);
  };

  // Should we try IndexedDB first?
  if (!fetchAttrReplace || requestMethod === 'EM_IDB_STORE' || requestMethod === 'EM_IDB_DELETE') {
    if (!Fetch.dbInstance) {

      console.error('fetch: failed to read IndexedDB! Database is not open.');

      reportError(fetch, 0, 'IndexedDB is not open');
      return 0; // todo: free
    }

    if (requestMethod === 'EM_IDB_STORE') {
      var dataPtr = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestData >> 2];
      var dataLength = HEAPU32[fetch_attr + Fetch.attr_t_offset_requestDataSize >> 2];
      var data = HEAPU8.slice(dataPtr, dataPtr + dataLength); // TODO(?): Here we perform a clone of the data, because storing shared typed arrays to IndexedDB does not seem to be allowed.
      __emscripten_fetch_cache_data(Fetch.dbInstance, fetch, data, reportSuccess, reportError);
    } else if (requestMethod === 'EM_IDB_DELETE') {
      __emscripten_fetch_delete_cached_data(Fetch.dbInstance, fetch, reportSuccess, reportError);
    } else if (fetchAttrNoDownload) {
      __emscripten_fetch_load_cached_data(Fetch.dbInstance, fetch, reportSuccess, reportError);
    } else if (fetchAttrPersistFile) {
      __emscripten_fetch_load_cached_data(Fetch.dbInstance, fetch, reportSuccess, performCachedXhr);
    } else {
      __emscripten_fetch_load_cached_data(Fetch.dbInstance, fetch, reportSuccess, performUncachedXhr);
    }
  } else if (!fetchAttrNoDownload) {
    if (fetchAttrPersistFile) {
      __emscripten_fetch_xhr(fetch, cacheResultAndReportSuccess, reportError, reportProgress);
    } else {
      __emscripten_fetch_xhr(fetch, reportSuccess, reportError, reportProgress);
    }
  } else {

    console.error('fetch: Invalid combination of flags passed.');

    return 0; // todo: free
  }
  return fetch;
}

if (typeof Atomics === 'undefined') {
  // Polyfill singlethreaded atomics ops from http://lars-t-hansen.github.io/ecmascript_sharedmem/shmem.html#Atomics.add
  // No thread-safety needed since we don't have multithreading support.
  Atomics = {};
  Atomics['add'] = function(t, i, v) { var w = t[i]; t[i] += v; return w; }
  Atomics['and'] = function(t, i, v) { var w = t[i]; t[i] &= v; return w; }
  Atomics['compareExchange'] = function(t, i, e, r) { var w = t[i]; if (w == e) t[i] = r; return w; }
  Atomics['exchange'] = function(t, i, v) { var w = t[i]; t[i] = v; return w; }
  Atomics['wait'] = function(t, i, v, o) { if (t[i] != v) return 'not-equal'; else return 'timed-out'; }
  Atomics['wake'] = function(t, i, c) { return 0; }
  Atomics['wakeOrRequeue'] = function(t, i1, c, i2, v) { return 0; }
  Atomics['isLockFree'] = function(s) { return true; }
  Atomics['load'] = function(t, i) { return t[i]; }
  Atomics['or'] = function(t, i, v) { var w = t[i]; t[i] |= v; return w; }
  Atomics['store'] = function(t, i, v) { t[i] = v; return v; }
  Atomics['sub'] = function(t, i, v) { var w = t[i]; t[i] -= v; return w; }
  Atomics['xor'] = function(t, i, v) { var w = t[i]; t[i] ^= v; return w; }
}

var Atomics_add = Atomics.add;
var Atomics_and = Atomics.and;
var Atomics_compareExchange = Atomics.compareExchange;
var Atomics_exchange = Atomics.exchange;
var Atomics_wait = Atomics.wait;
var Atomics_wake = Atomics.wake;
var Atomics_wakeOrRequeue = Atomics.wakeOrRequeue;
var Atomics_isLockFree = Atomics.isLockFree;
var Atomics_load = Atomics.load;
var Atomics_or = Atomics.or;
var Atomics_store = Atomics.store;
var Atomics_sub = Atomics.sub;
var Atomics_xor = Atomics.xor;

var ENVIRONMENT_IS_FETCH_WORKER = true;
var ENVIRONMENT_IS_WORKER = true;
var ENVIRONMENT_IS_PTHREAD = true;
var __pthread_is_main_runtime_thread=0;
var DYNAMICTOP_PTR = 0;
var TOTAL_MEMORY = 0;
function enlargeMemory() {
  abort('Cannot enlarge memory arrays, since compiling with pthreads support enabled (-s USE_PTHREADS=1).');
}
var nan = NaN;
var inf = Infinity;

function _emscripten_asm_const_v() {}

function assert(condition) {
  if (!condition) console.error('assert failure!');
}

/// TODO: DO SOMETHING ABOUT ME.
function Pointer_stringify(ptr, /* optional */ length) {
  if (length === 0 || !ptr) return "";
  // TODO: use TextDecoder
  // Find the length, and check for UTF while doing so
  var hasUtf = 0;
  var t;
  var i = 0;
  while (1) {
    t = HEAPU8[(((ptr)+(i))>>0)];
    hasUtf |= t;
    if (t == 0 && !length) break;
    i++;
    if (length && i == length) break;
  }
  if (!length) length = i;

  var ret = "";

  if (hasUtf < 128) {
    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack
    var curr;
    while (length > 0) {
      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
      ret = ret ? ret + curr : curr;
      ptr += MAX_CHUNK;
      length -= MAX_CHUNK;
    }
    return ret;
  }
  return Module['UTF8ToString'](ptr);
}

Fetch.staticInit();

var queuePtr = 0;
var buffer = null;
var STACKTOP = 0;
var STACK_MAX = 0;
var HEAP8 = null;
var HEAPU8 = null;
var HEAP16 = null;
var HEAPU16 = null;
var HEAP32 = null;
var HEAPU32 = null;

function processWorkQueue() {
  if (!queuePtr) return;
  var numQueuedItems = Atomics_load(HEAPU32, queuePtr + 4 >> 2);
  if (numQueuedItems == 0) return;

  var queuedOperations = Atomics_load(HEAPU32, queuePtr >> 2);
  var queueSize = Atomics_load(HEAPU32, queuePtr + 8 >> 2);
  for(var i = 0; i < numQueuedItems; ++i) {
    var fetch = Atomics_load(HEAPU32, (queuedOperations >> 2)+i);
    function successcb(fetch) {
      Atomics.compareExchange(HEAPU32, fetch + Fetch.fetch_t_offset___proxyState >> 2, 1, 2);
      Atomics.wake(HEAP32, fetch + Fetch.fetch_t_offset___proxyState >> 2, 1);
    }
    function errorcb(fetch) {
      Atomics.compareExchange(HEAPU32, fetch + Fetch.fetch_t_offset___proxyState >> 2, 1, 2);
      Atomics.wake(HEAP32, fetch + Fetch.fetch_t_offset___proxyState >> 2, 1);
    }
    function progresscb(fetch) {
    }
    try {
      emscripten_start_fetch(fetch, successcb, errorcb, progresscb);
    } catch(e) {
      console.error(e);
    }
    /*
    if (interval != undefined) {
      clearInterval(interval);
      interval = undefined;
    }
    */
  }
  Atomics_store(HEAPU32, queuePtr + 4 >> 2, 0);
}

interval = 0;
this.onmessage = function(e) {
  if (e.data.cmd == 'init') {
    queuePtr = e.data.queuePtr;
    buffer = e.data.buffer;
    STACKTOP = e.data.STACKTOP;
    STACK_MAX = e.data.STACK_MAX;
    DYNAMICTOP_PTR = e.data.DYNAMICTOP_PTR;
    TOTAL_MEMORY = e.data.TOTAL_MEMORY;
    HEAP8 = new Int8Array(buffer);
    HEAPU8 = new Uint8Array(buffer);
    HEAP16 = new Int16Array(buffer);
    HEAPU16 = new Uint16Array(buffer);
    HEAP32 = new Int32Array(buffer);
    HEAPU32 = new Uint32Array(buffer);
    interval = setInterval(processWorkQueue, 100);
  }
}
